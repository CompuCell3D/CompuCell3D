/**
 * @file    L3Parser.ypp
 * @brief   Definition of the SBML Level 3 infix-to-mathml parser.
 * @author  Lucian Smith
 * 
 * <!--------------------------------------------------------------------------
 * This file is part of libSBML.  Please visit http://sbml.org for more
 * information about SBML, and the latest version of libSBML.
 *
 * Copyright (C) 2009-2012 jointly by the following organizations: 
 *     1. California Institute of Technology, Pasadena, CA, USA
 *     2. EMBL European Bioinformatics Institute (EBML-EBI), Hinxton, UK
 *  
 * Copyright (C) 2006-2008 by the California Institute of Technology,
 *     Pasadena, CA, USA 
 *  
 * Copyright (C) 2002-2005 jointly by the following organizations: 
 *     1. California Institute of Technology, Pasadena, CA, USA
 *     2. Japan Science and Technology Agency, Japan
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation.  A copy of the license agreement is provided
 * in the file named "LICENSE.txt" included with this software distribution and
 * also available online as http://sbml.org/software/libsbml/license.html
 * ---------------------------------------------------------------------- -->*/

/**
 * This file is designed to be compiled by the 'bison' program with the
 * command:
 *
 * bison -v L3Parser.ypp -o L3Parser.cpp
 *
 * The '-v' creates a file called 'L3Parser.output' which can be examined
 * to piece together the explicit logic of the parser, and the -o specifies
 * the output file (L3Parser.cpp instead of the default L3Parser.tab.cpp)
 *
 * This command produces the file 'L3Parser.cpp' which is included
 * explicitly in the libsbml distribution.  Automatic creation of this
 * file is not yet incorporated into the CMake system; it must be
 * run by hand before change here will make it into the actual libsbml
 * library.
 *
 * Bison v2.4.2 was used to create the .cpp file when this file was
 * first created.  It does not rely on odd features of the bison
 * parser, so other versions should work fine.
 *
 * This file currently compiles with zero reduce/reduce errors and zero
 * shift/reduce warnings.
 */

%code top {

 /** @cond doxygen-libsbml-internal */
}

%{
/**
 *
 * This file is AUTOMATICALLY GENERATED by the 'bison' program and
 * should not be modified directly.  It is created with the command
 *
 * bison -v L3Parser.ypp -o L3Parser.cpp
 *
 * from the L3Parser.ypp file.  Any modifications should be performed on
 * that file directly.
 *
 * This file defines an entire class, 'L3Parser', that does not appear
 * in any header file, as it is only useful in the context of the C functions
 * generated by the bison program.  Future versions of this parser may
 * use a version of bison that generates a parser object instead of C
 * functions, but for now, the only interface with the library is defined
 * in the L3Parser.h file.
 */

#include <sbml/common/libsbml-namespace.h>
#include <sbml/math/L3Parser.h>
#include <sbml/Model.h>
#include <sbml/math/L3ParserSettings.h>

#include <sstream>

LIBSBML_CPP_NAMESPACE_USE
LIBSBML_CPP_NAMESPACE_BEGIN
class SBMLVisitor;
class FormulaUnitsData;

#ifndef SWIG //Hide the entire class from SWIG
/**
 * @class L3Parser
 * @brief Class providing functionality for the bison-generated parser.
 *
 * The L3Parser class is an internal class designed to hold the guts of the bison parser, plus
 * the lexer.  It is designed to be a global singleton object, because that's the cleanest way
 * I could find to incorporate functions into the bison framework.
 *
 * The functions declared in this file are defined in the file L3Parser.ypp, which
 * must be compiled by bison to create L3Parser.cpp, the file included in
 * libsbml.  For more details, see the L3Parser.ypp file.
 *
 * Within the various 'sbml_yylex*' functions that bison creates, functions
 * from the global 'l3p' object (of the L3Parser class) are used to calculate
 * necessary information for the parsing of the string, and to determine appropriate
 * error messages when things go wrong.
 * @internal
 */
class LIBSBML_EXTERN L3Parser
{
public:

  std::stringstream input;
  ASTNode* outputNode;
  std::string error;
  std::map<std::string, std::string*> words;
  long exponent;
  long denominator;

  //settings:
  L3ParserSettings defaultL3ParserSettings;
  const Model* model;
  ParseLogType_t parselog;
  bool collapseminus;
  bool parseunits;
  bool avocsymbol;

  L3Parser();
  ~L3Parser();

  //Functions needed for the parser and the lexer:
  /**
   * Compares 'name' against a list of known constants, and returns the particular
   * constant type (AST_CONSTANT_TRUE, AST_CONSTANT_PI, AST_NAME_TIME) associated
   * with that string (with case ignored).  For the mathematical constants
   * infinity and notanumber, AST_REAL is returned, and the parser must then
   * examine the string again to discover what to do with the ASTNode.
   */
  ASTNodeType_t getSymbolFor(std::string name) const;
  /**
   * Compares 'name' against a list of known functions allowed in the MathML
   * of SBML Level 2 and 3.  Multiple mappings of string->type are present,
   * so that (for example) both the strings 'acos' and 'arccos' return the
   * type AST_FUNCTION_ARCCOS.  "log" returns AST_FUNCTION_LOG, so when 
   * user preference is taken into consideration, 'name' must once again
   * be checked.
   */
  ASTNodeType_t getFunctionFor(std::string name) const;
  /**
   * This function creates an ASTNode that is a 'piecewise' function that
   * mimics the 'modulo' function 'x % y'.  It was modified from the
   * function of the same name in Copasi in its  CEvaluationNodeOperator 
   * class, which itself had modifications submitted by Frank Bergmann.  
   */
  ASTNode*      createModuloTree(ASTNode* x, ASTNode* y) const;
  /**
   * Sets the member variable 'collapseminus' to the provided boolean value.  Used in parsing
   * unary minuses.
   */
  void setCollapseMinus(bool collapse);
  /**
   * Sets the member variable 'parselog' to the provided enum.  Used in parsing
   * strings with the function "log" with a single argument.
   */
  void setParseLog(ParseLogType_t parseas);
  /**
   * Sets the member variable 'parseunits' to the provided boolean.  Used in
   * deciding whether strings that assign units to numbers (like "10 mL") 
   * are parsed correctly, or as errors.
   */
  void setParseUnits(bool units);
  /**
   * Sets the member variable 'avocsymbol' to the provided boolean. Used in
   * deciding whether to parse the string 'avogadro' as an ASTNode of type
   * AST_NAME_AVOGADRO or AST_NAME with the name 'avogadro'.
   */
  void setAvoCsymbol(bool avo);
  /**
   * Compares the two strings, and returns 'true' if they are equivalent,
   * ignoring case.  Used in the parser and in the 'getSymbolFor' and 
   * 'getFunctionFor' functions.
   */
  bool caselessStrCmp(const std::string& lhs, const std::string& rhs) const;
  /**
   * Sets the input string to be parsed, copied to the 'input' stringstream
   * member variable.
   */
  void setInput(const char* c);
  /**
   * Sets the error string so that it can be retrieved by the function 
   * 'SBML_getLastParseL3Error'.
   */
  void setError(const char* c);
  /**
   * Sets the error string so that it can be retrieved by the function 
   * 'SBML_getLastParseL3Error'.
   */
  void setError(std::string c);
  /**
   * Resets the L3Parser object, removing any error or input strings,
   * setting the output ASTNode to NULL, and resetting all parser settings
   * to that stored in the 'defaultL3ParserSettings' member variable.
   */
  void clear();
  /**
   * Returns the 'error' member variable, which is either empty or contains
   * the error message set from a 'setError' function.
   */
  std::string getError();
  
  /**
   * The bison parser needs string pointers to pass around from function to
   * function.  In order to not create too many of these objects, and to
   * ensure that they are properly deleted, the lexer calls this function
   * when it encounters a valid ID string to get a stable pointer that can 
   * be passed to the parser functions.
   * 
   * In this function, 'word' is looked up in a hash map of strings to 
   * string pointers; if it is not found, a new string pointer containing
   * the string is created, added to the hash, and returned.  If it is
   * found, the previously-created pointer is returned.
   */
  std::string* addWord(const std::string& word);
  
  /**
   * This function checks the provided ASTNode function to see if it is a 
   * known function with the wrong number of arguments.  If so, an error is set
   * (using the 'setError' function) and 'true' is returned.  If the
   * correct number of arguments is provided, 'false' is returned.
   */
  bool checkNumArguments(const ASTNode* function);

  /**
   * Provides a copy of the default parser settings member variable.
   */
  L3ParserSettings getDefaultL3ParserSettings();

  /*
   * Change the default settings for this parser to the settings provided.  All subsequent
   * calls to parseL3Formula with no 'settings' argument will use these settings
   * instead of the defaults.
   */
  void setDefaultSettings(L3ParserSettings settings);

  /**
   * If the either versions of the function @see SBML_parseL3Formula() returns NULL, an error 
   * is set internally which is accessible via this function.  The returned error will 
   * report the string it was trying to parse, which character it had parsed when it 
   * encountered the error, and what the error was.
   * 
   */
  static char* getLastParseL3Error();
};
#endif //The entire class should be invisible to SWIG, too.

LIBSBML_CPP_NAMESPACE_END

  using namespace std;

  int sbml_yylex(void);
  L3Parser* l3p = NULL;
  void sbml_yyerror(char const *);
  int sbml_yylloc_first_position = 1;
  int sbml_yylloc_last_position = 1;
%}

/*Bison declarations */
%union {
  ASTNode* astnode;
  char character;
  const string* word;
  double numdouble;
  long   numlong;
  double mantissa;
  long   rational;
}

%type <astnode> node nodelist number

%left '&' '|' /* Boolean functions and, or */
%left '<' '>' '=' '!' /* Boolean comparison functions (gt, lt, eq, etc.) */
%left NOT /* boolean negation--unary not */
%left '-' '+'
%left '*' '/' '%'
%right '^'    /* exponentiation        */
%left NEG     /* negation--unary minus */

%token YYEOF 0 "end of string"
%token  <numdouble> DOUBLE "number"
%token  <numlong> INTEGER "integer"
%token  <mantissa> E_NOTATION "number in e-notation form"
%token  <rational> RATIONAL "number in rational notation"
%token  <word> SYMBOL "element name"

%name-prefix="sbml_yy"
%debug
%error-verbose
%% /* The grammar: */

input:          /* empty */
        |       node {l3p->outputNode = $1;}
        |       error {}
        |       node error {delete $1;}
        ;

node:           number {$$ = $1;}
        |       SYMBOL {
                   $$ = new ASTNode();
                   string name(*$1);
                   $$->setName(name.c_str());
                   if (l3p->model == NULL ||
                       (l3p->model->getSpecies(name) == NULL
                        && l3p->model->getCompartment(name) == NULL
                        && l3p->model->getReaction(name) == NULL
                        && l3p->model->getParameter(name) == NULL
                        && l3p->model->getSpeciesReference(name) == NULL)) {
                     //The symbol is not used in any other mathematical context in the SBML model, so we can see if it matches a list of pre-defined names
                     ASTNodeType_t type = l3p->getSymbolFor(name);
                     if (type != AST_UNKNOWN) $$->setType(type);
                     if (type==AST_REAL) {
                       if (l3p->caselessStrCmp(name, "inf"))          $$->setValue(numeric_limits<double>::infinity());
                       if (l3p->caselessStrCmp(name, "infinity"))     $$->setValue(numeric_limits<double>::infinity());
                       if (l3p->caselessStrCmp(name, "nan"))          $$->setValue(numeric_limits<double>::quiet_NaN());
                       if (l3p->caselessStrCmp(name, "notanumber"))   $$->setValue(numeric_limits<double>::quiet_NaN());
                     }
                     if (!l3p->avocsymbol && type==AST_NAME_AVOGADRO) {
                       //Don't parse 'avogadro' as a csymbol.
                       $$->setName(name.c_str());
                       $$->setType(AST_NAME);
                     }
                   }
        }
        |       '(' node ')'  {$$ = $2;}
        |       node '^' node {$$ = new ASTNode(AST_POWER); $$->addChild($1); $$->addChild($3);}
        |       node '*' node {
                  if ($1->getType()==AST_TIMES) {
                    $$ = $1;
                    $$->addChild($3);
                  }
                  else {
                    $$ = new ASTNode(AST_TIMES);
                    $$->addChild($1);
                    $$->addChild($3);
                  }
                }
        |       node '+' node {
                  if ($1->getType()==AST_PLUS) {
                    $$ = $1;
                    $$->addChild($3);
                  }
                  else {
                    $$ = new ASTNode(AST_PLUS);
                    $$->addChild($1);
                    $$->addChild($3);
                  }
                }
        |       node '/' node {$$ = new ASTNode(AST_DIVIDE); $$->addChild($1); $$->addChild($3);}
        |       node '-' node {$$ = new ASTNode(AST_MINUS); $$->addChild($1); $$->addChild($3);}
        |       node '%' node {$$ = l3p->createModuloTree($1, $3);}
        |       node '>' node {$$ = new ASTNode(AST_RELATIONAL_GT); $$->addChild($1); $$->addChild($3);}
        |       node '<' node {$$ = new ASTNode(AST_RELATIONAL_LT); $$->addChild($1); $$->addChild($3);}
        |       '-' node %prec NEG {
                  if (l3p->collapseminus) {
                    if ($2->getType()==AST_REAL) {
                      $$ = $2;
                      $$->setValue(-$$->getReal());
                    }
                    else if ($2->getType()==AST_INTEGER) {
                      $$ = $2;
                      $$->setValue(-$$->getInteger());
                    }
                    else if ($2->getType()==AST_REAL_E) {
                      $$ = $2;
                      $$->setValue(-$$->getMantissa(), $$->getExponent());
                    }
                    else if ($2->getType()==AST_RATIONAL) {
                      $$ = $2;
                      $$->setValue(-$$->getNumerator(), $$->getDenominator());
                    }
                    else if ($2->getType()==AST_MINUS && $2->getNumChildren()==1) {
                      $$ = $2->getChild(0);
                      $2->removeChild(0);
                      delete $2;
                    }
                    else {
                      $$ = new ASTNode(AST_MINUS);    
                      $$->addChild($2);
                    }
                  }
                  else {
                    $$ = new ASTNode(AST_MINUS);
                    $$->addChild($2);
                  }
                }
        |       node '>' '=' node {$$ = new ASTNode(AST_RELATIONAL_GEQ); $$->addChild($1); $$->addChild($4);}
        |       node '<' '=' node {$$ = new ASTNode(AST_RELATIONAL_LEQ); $$->addChild($1); $$->addChild($4);}
        |       node '=' '=' node {$$ = new ASTNode(AST_RELATIONAL_EQ); $$->addChild($1); $$->addChild($4);}
        |       node '!' '=' node {$$ = new ASTNode(AST_RELATIONAL_NEQ); $$->addChild($1); $$->addChild($4);}
        |       node '<' '>' node {$$ = new ASTNode(AST_RELATIONAL_NEQ); $$->addChild($1); $$->addChild($4);}
        |       node '>' '<' node {$$ = new ASTNode(AST_RELATIONAL_NEQ); $$->addChild($1); $$->addChild($4);}
        |       node '&' '&' node {$$ = new ASTNode(AST_LOGICAL_AND); $$->addChild($1); $$->addChild($4);}
        |       node '|' '|' node {$$ = new ASTNode(AST_LOGICAL_OR); $$->addChild($1); $$->addChild($4);}
        |       '!' node %prec NOT {$$ = new ASTNode(AST_LOGICAL_NOT); $$->addChild($2);}
        |       SYMBOL '(' ')' {
                   $$ = new ASTNode(AST_FUNCTION);
                   string name(*$1);
                   $$->setName($1->c_str());
                   if (l3p->model == NULL || l3p->model->getFunctionDefinition(name) == NULL) {
                     //The symbol is not used in any other mathematical context in the SBML model, so we can see if it matches a list of pre-defined names
                     ASTNodeType_t type = l3p->getFunctionFor(name);
                     if (type != AST_UNKNOWN) $$->setType(type);
                     if (l3p->checkNumArguments($$)) YYABORT;
                   }
        }
        |       SYMBOL '(' nodelist ')' {
                   $$ = $3;
                   string name(*$1);
                   $$->setName($1->c_str());
                   $$->setType(AST_FUNCTION);
                   if (l3p->model == NULL || l3p->model->getFunctionDefinition(name) == NULL) {
                     //The symbol is not used in any other mathematical context in the SBML model, so we can see if it matches a list of pre-defined names
                     ASTNodeType_t type = l3p->getFunctionFor(name);
                     if (type != AST_UNKNOWN) $$->setType(type);
                     if (type==AST_FUNCTION_ROOT && l3p->caselessStrCmp(name, "sqrt")) {
                       //Add a '2' node before the existing child.
                       ASTNode* int2 = new ASTNode(AST_INTEGER);
                       int2->setValue(2);
                       $$->prependChild(int2);
                     }
                     if (type==AST_FUNCTION_POWER && l3p->caselessStrCmp(name, "sqr")) {
                       //Add a '2' node after the existing child.
                       ASTNode* int2 = new ASTNode(AST_INTEGER);
                       int2->setValue(2);
                       $$->addChild(int2);
                     }
                     if (type==AST_FUNCTION_LOG && l3p->caselessStrCmp(name, "log10")) {
                       //Add a '10' node before the existing child.
                       ASTNode* int10 = new ASTNode(AST_INTEGER);
                       int10->setValue(10);
                       $$->prependChild(int10);
                     }
                     if (type==AST_FUNCTION_LOG && l3p->caselessStrCmp(name, "log")) {
                       //If there is exactly one argument, change it to log10, ln, or give a special error message, depending on a user setting (by default, parse to log10).
                       if ($$->getNumChildren() == 1) {
                         ASTNode* int10;
                         switch(l3p->parselog) {
                         case L3P_PARSE_LOG_AS_LOG10:
                           int10 = new ASTNode(AST_INTEGER);
                           int10->setValue(10);
                           $$->prependChild(int10);
                           break;
                         case L3P_PARSE_LOG_AS_LN:
                           $$->setType(AST_FUNCTION_LN);
                           break;
                         case L3P_PARSE_LOG_AS_ERROR:
                           l3p->setError("Writing a function as 'log(x)' was legal in the L1 parser, but translated as the natural log, not the base-10 log.  This construct is disallowed entirely as being ambiguous, and you are encouraged instead to use 'ln(x)', 'log10(x)', or 'log(base, x)'.");
                           YYABORT;
                         }
                       }
                     }
                   }
                   if (l3p->checkNumArguments($$)) YYABORT;
        }
        ;

number:         DOUBLE {$$ = new ASTNode(); $$->setValue($1);} 
        |       E_NOTATION {$$ = new ASTNode(); $$->setValue($1, l3p->exponent);}
        |       INTEGER {$$ = new ASTNode(); $$->setValue($1);}
        |       RATIONAL {$$ = new ASTNode(); $$->setValue($1, l3p->denominator);}
        |       number SYMBOL {
                  $$ = $1;
                  if ($$->getUnits() != "") {
                    l3p->setError("Can't use " + *$2 + " as a unit, because the unit is already set for this number.");
                    YYERROR;
                  }
                  if (!l3p->parseunits) {
                    l3p->setError("The ability to associate units with numbers has been disabled.");
                    YYERROR;
                  }
                  $$->setUnits(*$2);
               }
        ;

nodelist:       node {$$ = new ASTNode(AST_FUNCTION); $$->addChild($1);}
        |       nodelist ',' node {$$ = $1;  $$->addChild($3);}
        ;

%%


void sbml_yyerror(char const *s)
{
  l3p->setError(s);
}

int sbml_yylex(void)
{
  char cc = 0;
  l3p->input.get(cc);

  //If we're done with the input:
  if (l3p->input.eof()) {
    return 0;
  }
  //If something else went wrong:
  if (!l3p->input.good()) {
    l3p->setError("The input is no longer good, for an unknown reason.");
    return -1;
  }

  // Skip white space.
  while ((cc == ' ' || cc == '\t' || cc == '\n' || cc == '\r')
         && !l3p->input.eof()) {
    l3p->input.get(cc);
  }
  if (l3p->input.eof()) return 0;

  // Parse words
  if (isalpha(cc) || cc == '_') {
    string word;
    while ((isalpha(cc) || isdigit(cc) || cc == '_') && !l3p->input.eof()) {
      word += cc;
      l3p->input.get(cc);
    }
    if (!l3p->input.eof()) {
      l3p->input.unget();
    }
    sbml_yylval.word = l3p->addWord(word);
    //cout << "\tRead word '" << word << "'." << endl;
    return SYMBOL;
  }

  // Parse numbers
  if (isdigit(cc) || (cc=='.' && isdigit(l3p->input.peek()))) {
    double number;
    long numlong;
    l3p->input.unget();
    streampos numbegin = l3p->input.tellg();
    l3p->input >> numlong;
    l3p->input.clear();
    l3p->input.seekg(numbegin);
    l3p->input >> number;
    if (l3p->input.fail()) {
      //The only reason I know of for this to happen is that there was a number followed by an 'e'.
      l3p->input.clear(); //clear the error.
      l3p->input.seekg(numbegin);
      string failnum = "";
      cc = l3p->input.get();
      while (l3p->input.good() && (isdigit(cc) || cc=='.')) {
        failnum += cc;
        cc = l3p->input.get();
      }
      if (cc=='e' || cc=='E') {
        l3p->input.unget();
        //We're going to call yylex recursively here, so we need to swap out l3p->input
        streampos numend = l3p->input.tellg();
        string tempinput = l3p->input.str();
        l3p->input.str(failnum);
        int ret = sbml_yylex();
        l3p->input.str(tempinput);
        l3p->input.clear();
        l3p->input.seekg(numend);
        return ret;
      }
      //Something weird went wrong; give up.
      return -1;
    }
    streampos numend = l3p->input.tellg();
    l3p->input.clear();
    l3p->input.seekg(numbegin);
    bool decimal = false;
    bool e = false;
    bool last_e = false;
    while (l3p->input.tellg() != numend) {
      cc = l3p->input.get();
      if (cc=='.') {
        decimal = true;
      }
      if (cc=='e' || cc=='E') {
        e = true;
        last_e = true;
      }
      else {
        last_e = false;
      }
    }
    if (last_e) {
       e = false;
       l3p->input.unget();
    }
    if (!decimal && !e && number == static_cast<double>(numlong) && numlong <= SBML_INT_MAX) {
      sbml_yylval.numlong = numlong;
      return INTEGER;
    }
    if (!e) {
      sbml_yylval.numdouble = number;
      return DOUBLE;
    }
    l3p->input.clear();
    l3p->input.seekg(numbegin);
    cc = l3p->input.get();
    string mantissa = "";
    while (l3p->input.tellg() != numend && (isdigit(cc) || cc=='.')) {
      mantissa += cc;
      cc = l3p->input.get();
    }
    if (cc=='e' || cc=='E') {
      if (l3p->input.peek()=='+') {
        cc = l3p->input.get();
      }
      bool isneg = false;
      if (l3p->input.peek()=='-') {
        cc = l3p->input.get();
        isneg = true;
      }
      l3p->input >> numlong;
      if (isneg) {
        numlong = -numlong;
      }
      stringstream mantissastr;
      mantissastr.str(mantissa);
      mantissastr >> number;
      l3p->exponent = numlong;
      sbml_yylval.mantissa = number;
      return E_NOTATION;
    }
    else {
      assert(false); //How did this happen?
      //This is an error condition, but parsing the value as a double should be sufficient.
      sbml_yylval.numdouble = number;
      return DOUBLE;
    }
  }
  else if (cc=='(') {
    streampos rationalbegin = l3p->input.tellg();
    cc = l3p->input.get();
    if ((cc== '-' && isdigit(l3p->input.peek())) || isdigit(cc)) {
      l3p->input.unget();
      long numerator;
      l3p->input >> numerator;
      cc = l3p->input.get();
      if (cc=='/') {
        cc = l3p->input.get();
        if ((cc== '-' && isdigit(l3p->input.peek())) || isdigit(cc)) {
          l3p->input.unget();
          long denominator;
          l3p->input >> denominator; 
          cc = l3p->input.get();
          if (cc==')') {
            //Actually a rational number!
            sbml_yylval.rational = numerator;
            l3p->denominator = denominator;
            return RATIONAL;
          }
        }
      }
    }
    l3p->input.clear();
    l3p->input.seekg(rationalbegin, ios::beg); // Not actually a rational number.
    return '(';
  }

  //Otherwise, return the character we are looking at (like '*', '+', etc.
  return cc;
}

L3Parser::L3Parser()
  : input()
  , outputNode(NULL)
  , error()
  , words()
  , exponent(0)
  , denominator(0)
  , defaultL3ParserSettings()
  , model(NULL)
  , parselog(L3P_PARSE_LOG_AS_LOG10)
  , collapseminus(L3P_EXPAND_UNARY_MINUS)
  , parseunits(L3P_PARSE_UNITS)
  , avocsymbol(L3P_AVOGADRO_IS_CSYMBOL)
{
}

L3Parser::~L3Parser ()
{
  for (map<string, string*>::iterator word = words.begin(); word != words.end(); word++) {
    delete (*word).second;
  }
}

ASTNodeType_t L3Parser::getSymbolFor(string name) const
{
  if (caselessStrCmp(name, "true"))         return AST_CONSTANT_TRUE;
  if (caselessStrCmp(name, "false"))        return AST_CONSTANT_FALSE;
  if (caselessStrCmp(name, "pi"))           return AST_CONSTANT_PI;
  if (caselessStrCmp(name, "exponentiale")) return AST_CONSTANT_E;
  if (caselessStrCmp(name, "avogadro"))     return AST_NAME_AVOGADRO;
  if (caselessStrCmp(name, "time"))         return AST_NAME_TIME;
  if (caselessStrCmp(name, "inf"))          return AST_REAL;
  if (caselessStrCmp(name, "infinity"))     return AST_REAL;
  if (caselessStrCmp(name, "nan"))          return AST_REAL;
  if (caselessStrCmp(name, "notanumber"))   return AST_REAL;
  return AST_UNKNOWN;
}

ASTNodeType_t L3Parser::getFunctionFor(string name) const
{
  if (caselessStrCmp(name, "abs"))      return AST_FUNCTION_ABS;
  if (caselessStrCmp(name, "acos"))     return AST_FUNCTION_ARCCOS;
  if (caselessStrCmp(name, "arccos"))   return AST_FUNCTION_ARCCOS;
  if (caselessStrCmp(name, "acosh"))    return AST_FUNCTION_ARCCOSH;
  if (caselessStrCmp(name, "arccosh"))  return AST_FUNCTION_ARCCOSH;
  if (caselessStrCmp(name, "acot"))     return AST_FUNCTION_ARCCOT;
  if (caselessStrCmp(name, "arccot"))   return AST_FUNCTION_ARCCOT;
  if (caselessStrCmp(name, "acoth"))    return AST_FUNCTION_ARCCOTH;
  if (caselessStrCmp(name, "arccoth"))  return AST_FUNCTION_ARCCOTH;
  if (caselessStrCmp(name, "acsc"))     return AST_FUNCTION_ARCCSC;
  if (caselessStrCmp(name, "arccsc"))   return AST_FUNCTION_ARCCSC;
  if (caselessStrCmp(name, "acsch"))    return AST_FUNCTION_ARCCSCH;
  if (caselessStrCmp(name, "arccsch"))  return AST_FUNCTION_ARCCSCH;
  if (caselessStrCmp(name, "asec"))     return AST_FUNCTION_ARCSEC;
  if (caselessStrCmp(name, "arcsec"))   return AST_FUNCTION_ARCSEC;
  if (caselessStrCmp(name, "asech"))    return AST_FUNCTION_ARCSECH;
  if (caselessStrCmp(name, "arcsech"))  return AST_FUNCTION_ARCSECH;
  if (caselessStrCmp(name, "asin"))     return AST_FUNCTION_ARCSIN;
  if (caselessStrCmp(name, "arcsin"))   return AST_FUNCTION_ARCSIN;
  if (caselessStrCmp(name, "atan"))     return AST_FUNCTION_ARCTAN;
  if (caselessStrCmp(name, "arctan"))   return AST_FUNCTION_ARCTAN;
  if (caselessStrCmp(name, "atanh"))    return AST_FUNCTION_ARCTANH;
  if (caselessStrCmp(name, "arctanh"))  return AST_FUNCTION_ARCTANH;
  if (caselessStrCmp(name, "ceil"))     return AST_FUNCTION_CEILING;
  if (caselessStrCmp(name, "ceiling"))  return AST_FUNCTION_CEILING;
  if (caselessStrCmp(name, "cos"))      return AST_FUNCTION_COS;
  if (caselessStrCmp(name, "cosh"))     return AST_FUNCTION_COSH;
  if (caselessStrCmp(name, "cot"))      return AST_FUNCTION_COT;
  if (caselessStrCmp(name, "coth"))     return AST_FUNCTION_COTH;
  if (caselessStrCmp(name, "csc"))      return AST_FUNCTION_CSC;
  if (caselessStrCmp(name, "csch"))     return AST_FUNCTION_CSCH;
  if (caselessStrCmp(name, "delay"))    return AST_FUNCTION_DELAY;
  if (caselessStrCmp(name, "exp"))      return AST_FUNCTION_EXP;
  if (caselessStrCmp(name, "factorial")) return AST_FUNCTION_FACTORIAL;
  if (caselessStrCmp(name, "floor"))    return AST_FUNCTION_FLOOR;
  if (caselessStrCmp(name, "lambda"))   return AST_LAMBDA;
  if (caselessStrCmp(name, "log"))      return AST_FUNCTION_LOG;
  if (caselessStrCmp(name, "ln"))       return AST_FUNCTION_LN;
  if (caselessStrCmp(name, "log10"))    return AST_FUNCTION_LOG;
  if (caselessStrCmp(name, "piecewise")) return AST_FUNCTION_PIECEWISE;
  if (caselessStrCmp(name, "power"))    return AST_POWER;
  if (caselessStrCmp(name, "pow"))      return AST_POWER;
  if (caselessStrCmp(name, "sqr"))      return AST_FUNCTION_POWER;
  if (caselessStrCmp(name, "sqrt"))     return AST_FUNCTION_ROOT;
  if (caselessStrCmp(name, "root"))     return AST_FUNCTION_ROOT;
  if (caselessStrCmp(name, "sec"))      return AST_FUNCTION_SEC;
  if (caselessStrCmp(name, "sech"))     return AST_FUNCTION_SECH;
  if (caselessStrCmp(name, "sin"))      return AST_FUNCTION_SIN;
  if (caselessStrCmp(name, "sinh"))     return AST_FUNCTION_SINH;
  if (caselessStrCmp(name, "tan"))      return AST_FUNCTION_TAN;
  if (caselessStrCmp(name, "tanh"))     return AST_FUNCTION_TANH;
  if (caselessStrCmp(name, "and"))      return AST_LOGICAL_AND;
  if (caselessStrCmp(name, "not"))      return AST_LOGICAL_NOT;
  if (caselessStrCmp(name, "or"))       return AST_LOGICAL_OR;
  if (caselessStrCmp(name, "xor"))      return AST_LOGICAL_XOR;
  if (caselessStrCmp(name, "eq"))       return AST_RELATIONAL_EQ;
  if (caselessStrCmp(name, "equals"))   return AST_RELATIONAL_EQ;
  if (caselessStrCmp(name, "geq"))      return AST_RELATIONAL_GEQ;
  if (caselessStrCmp(name, "gt"))       return AST_RELATIONAL_GT;
  if (caselessStrCmp(name, "leq"))      return AST_RELATIONAL_LEQ;
  if (caselessStrCmp(name, "lt"))       return AST_RELATIONAL_LT;
  if (caselessStrCmp(name, "neq"))      return AST_RELATIONAL_NEQ;
  if (caselessStrCmp(name, "divide"))   return AST_DIVIDE;
  if (caselessStrCmp(name, "minus"))    return AST_MINUS;
  if (caselessStrCmp(name, "plus"))     return AST_PLUS;
  if (caselessStrCmp(name, "times"))    return AST_TIMES;
  return AST_UNKNOWN;
}

ASTNode* L3Parser::createModuloTree(ASTNode* x, ASTNode* y) const
{
  if (x==NULL || y==NULL) return NULL;
  ASTNode* pASTNode = new ASTNode(); 
  //The following code was lifted wholesale from Copasi's  CEvaluationNodeOperator::createModuloTree.  Thanks, Copasi!

  // Frank noticed that this should actually be implemented as a
  // piecewise function because if one of the arguments is
  // negative, the definition is different
  pASTNode->setType(AST_FUNCTION_PIECEWISE);
  // the first child is the true branch
  // x%y -> x-ceil(x/y)*y
  ASTNode* pASTNodeTrue = new ASTNode();
  pASTNodeTrue->setType(AST_MINUS);
  ASTNode* tmpASTNode = new ASTNode(AST_DIVIDE);
  tmpASTNode->addChild(x);
  tmpASTNode->addChild(y);
  ASTNode* tmpASTNode2 = new ASTNode(AST_FUNCTION_CEILING);
  tmpASTNode2->addChild(tmpASTNode);
  tmpASTNode = new ASTNode(AST_TIMES);
  tmpASTNode->addChild(new ASTNode(*y));
  tmpASTNode->addChild(tmpASTNode2);
  pASTNodeTrue->addChild(new ASTNode(*x));
  pASTNodeTrue->addChild(tmpASTNode);
  pASTNode->addChild(pASTNodeTrue);
  // now comes the condition
  // if exactly one of the arguments to modulo is a negative number
  // we use the ceil branch, else we use the floor branch
  // x < 0 xor y < 0
  // xor
  ASTNode* pASTNodeCondition = new ASTNode();
  pASTNodeCondition->setType(AST_LOGICAL_XOR);
  // x < 0
  // <
  tmpASTNode = new ASTNode(AST_RELATIONAL_LT);
  // x
  tmpASTNode->addChild(new ASTNode(*x));
  // 0
  tmpASTNode2 = new ASTNode(AST_INTEGER);
  tmpASTNode2->setValue(0);
  tmpASTNode->addChild(tmpASTNode2);
  pASTNodeCondition->addChild(tmpASTNode);
  // y < 0
  // <
  tmpASTNode = new ASTNode(AST_RELATIONAL_LT);
  // y
  tmpASTNode->addChild(new ASTNode(*y));
  // 0
  tmpASTNode2 = new ASTNode(AST_INTEGER);
  tmpASTNode2->setValue(0);
  tmpASTNode->addChild(tmpASTNode2);
  pASTNodeCondition->addChild(tmpASTNode);
  pASTNode->addChild(pASTNodeCondition);
  // last is the false branch
  // x%y -> x-floor(x/y)*y
  ASTNode* pASTNodeFalse = new ASTNode();
  pASTNodeFalse->setType(AST_MINUS);
  tmpASTNode = new ASTNode(AST_DIVIDE);
  tmpASTNode->addChild(new ASTNode(*x));
  tmpASTNode->addChild(new ASTNode(*y));
  tmpASTNode2 = new ASTNode(AST_FUNCTION_FLOOR);
  tmpASTNode2->addChild(tmpASTNode);
  tmpASTNode = new ASTNode(AST_TIMES);
  tmpASTNode->addChild(new ASTNode(*y));
  tmpASTNode->addChild(tmpASTNode2);
  pASTNodeFalse->addChild(new ASTNode(*x));
  pASTNodeFalse->addChild(tmpASTNode);
  pASTNode->addChild(pASTNodeFalse);
  return pASTNode;
}

void L3Parser::setParseLog(ParseLogType_t parseas)
{
  parselog = parseas;
}

void L3Parser::setCollapseMinus(bool collapse)
{
  collapseminus = collapse;
}

void L3Parser::setParseUnits(bool units)
{
  parseunits = units;
}

void L3Parser::setAvoCsymbol(bool avo)
{
  avocsymbol = avo;
}

bool L3Parser::caselessStrCmp(const string& lhs, const string& rhs) const
{
  if (lhs.size() != rhs.size()) return false;

  for (size_t i = 0; i < lhs.size(); ++i) {
    if (toupper(lhs[i]) != toupper(rhs[i])) return false;
  }
  return true;

}

void L3Parser::setInput(const char* c)
{
  input.clear();
  input.str(c);
}

void L3Parser::setError(const char* c)
{
  string err = c;
  setError(err);
}

void L3Parser::setError(string c)
{
  stringstream err;
  streampos position = input.tellg();
  if (position== (streampos)-1) {
    position = input.str().size();
  }
  err << "Error when parsing input '" << input.str() << "' at position " << position << ":  " << c;
  error = err.str();
}

void L3Parser::clear()
{
  input.clear();
  input.str("");
  outputNode = NULL;
  error = "";
  model = defaultL3ParserSettings.getModel();
  parselog = defaultL3ParserSettings.getParseLog();
  collapseminus = defaultL3ParserSettings.getParseCollapseMinus();
  parseunits = defaultL3ParserSettings.getParseUnits();
  avocsymbol = defaultL3ParserSettings.getParseAvogadroCsymbol();
}

string L3Parser::getError()
{
  return error;
}
    
string* L3Parser::addWord(const std::string& word)
{
  //cout << "The word is: " << word << endl;
  map<string, string*>::iterator found = words.find(word);
  if (found != words.end()) {
    return (*found).second;
  }
  else {
    string* savedword = new string(word);
    words.insert(make_pair(word, savedword));
    return savedword;
  }
}

bool L3Parser::checkNumArguments(const ASTNode* function)
{
  unsigned int children = function->getNumChildren();
  stringstream error;
  string name = "";
  if (function->isOperator()) {
    name = function->getOperatorName();
  }
  else {
    name = function->getName();
  }
  error << "The function '" << name << "' takes ";
  switch(function->getType()) {
  case AST_FUNCTION_ABS:
  case AST_FUNCTION_ARCCOS:
  case AST_FUNCTION_ARCCOSH:
  case AST_FUNCTION_ARCCOT:
  case AST_FUNCTION_ARCCOTH:
  case AST_FUNCTION_ARCCSC:
  case AST_FUNCTION_ARCCSCH:
  case AST_FUNCTION_ARCSEC:
  case AST_FUNCTION_ARCSECH:
  case AST_FUNCTION_ARCSIN:
  case AST_FUNCTION_ARCSINH:
  case AST_FUNCTION_ARCTAN:
  case AST_FUNCTION_ARCTANH:
  case AST_FUNCTION_CEILING:
  case AST_FUNCTION_COS:
  case AST_FUNCTION_COSH:
  case AST_FUNCTION_COT:
  case AST_FUNCTION_COTH:
  case AST_FUNCTION_CSC:
  case AST_FUNCTION_CSCH:
  case AST_FUNCTION_EXP:
  case AST_FUNCTION_FACTORIAL:
  case AST_FUNCTION_FLOOR:
  case AST_FUNCTION_LN:
  case AST_FUNCTION_SEC:
  case AST_FUNCTION_SECH:
  case AST_FUNCTION_SIN:
  case AST_FUNCTION_SINH:
  case AST_FUNCTION_TAN:
  case AST_FUNCTION_TANH:
  case AST_LOGICAL_NOT:

    if (children != 1) {
      error << "exactly one argument, but " << children << " were found.";
      l3p->setError(error.str());
      return true;
    }
    return false;
  case AST_DIVIDE:
  case AST_POWER:
  case AST_RELATIONAL_NEQ:
  case AST_FUNCTION_DELAY:
  case AST_FUNCTION_POWER:
  case AST_FUNCTION_LOG:       // a log ASTNode has a child for base

    if (children != 2) {
      error << "exactly two arguments, but " << children << " were found.";
      l3p->setError(error.str());
      return true;
    }
    return false;

  case AST_RELATIONAL_EQ:
  case AST_RELATIONAL_GEQ:
  case AST_RELATIONAL_GT:
  case AST_RELATIONAL_LEQ:
  case AST_RELATIONAL_LT:
    if (children <= 1) {
      error << "at least two arguments, but " << children << " were found.";
      l3p->setError(error.str());
      return true;
    }
    return false;

  case AST_FUNCTION_PIECEWISE:
  case AST_LAMBDA:
    if (children == 0) {
      error << "at least one argument, but none were found.";
      l3p->setError(error.str());
      return true;
    }
    return false;

  case AST_FUNCTION_ROOT:
  case AST_MINUS:
    if (children < 1 || children > 2) {
      error << "exactly one or two arguments, but " << children << " were found.";
      l3p->setError(error.str());
      return true;
    }
    return false;
      
  case AST_TIMES:
  case AST_PLUS:
  case AST_LOGICAL_AND:
  case AST_LOGICAL_OR:
  case AST_LOGICAL_XOR:
  default:
    //n-ary 0 or more arguments
    return false;
  }
}

L3ParserSettings L3Parser::getDefaultL3ParserSettings()
{
  return defaultL3ParserSettings;
}

/** Everything above this point is internal. */
/** @endcond */

LIBSBML_CPP_NAMESPACE_BEGIN
BEGIN_C_DECLS

/** @cond doxygen-c-only */
/**
 * Parses the given mathematical formula and returns a representation of it
 * as an Abstract Syntax Tree (AST).
 *
 * The text-string form of mathematical formulas read by this function
 * are expanded versions of the formats produced and read by @if clike SBML_formulaToString()@endif@if csharp SBML_formulaToString()@endif@if python libsbml.formulaToString()@endif@if java <code><a href="libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)">libsbml.formulaToString()</a></code>@endif@~
 * and
 * @if clike SBML_parseFormula()@endif@if csharp SBML_parseFormula()@endif@if python libsbml.parseFormula()@endif@if java <code><a href="libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula()</a></code>@endif@~, 
 * respectively.  The latter two libSBML functions were originally
 * developed to support conversion between SBML Levels&nbsp;1 and&nbsp;2,
 * and were focused on the syntax of mathematical formulas used in SBML
 * Level&nbsp;1.  With time, and the use of MathML in SBML Levels&nbsp;2
 * and&nbsp;3, it became clear that supporting Level&nbsp;2 and&nbsp;3's
 * expanded mathematical syntax would be useful for software developers.
 * To maintain backwards compatibility, the original
 * @if clike SBML_formulaToString()@endif@if csharp SBML_formulaToString()@endif@if python libsbml.formulaToString()@endif@if java <code><a href="libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)">libsbml.formulaToString()</a></code>@endif@~
 * and
 * @if clike SBML_parseFormula()@endif@if csharp SBML_parseFormula()@endif@if python libsbml.parseFormula()@endif@if java <code><a href="libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula()</a></code>@endif@~
 * have been left untouched, and instead, the new functionality is
 * provided in the form of
 * @if clike SBML_parseL3Formula()@endif@if csharp SBML_parseL3Formula()@endif@if python libsbml.parseL3Formula()@endif@if java <code><a href="libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula()</a></code>@endif@~.
 *
 * The following are the differences in the formula syntax supported by
 * this function, compared to what is supported by  @if clike SBML_parseFormula()@endif@if csharp SBML_parseFormula()@endif@if python libsbml.parseFormula()@endif@if java <code><a href="libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula()</a></code>@endif@~:
 *
 * @li Units may be asociated with bare numbers, using the following syntax:
 * <div style="margin: 10px auto 10px 25px; display: block">
 * <span class="code" style="background-color: #d0d0ee">number</span>
 * <span class="code" style="background-color: #edd">unit</span>
 * </div>
 * The <span class="code" style="background-color: #d0d0ee">number</span>
 * may be in any form (an integer, real, or rational
 * number), and the 
 * <span class="code" style="background-color: #edd">unit</span>
 * must conform to the syntax of an SBML identifier (technically, the
 * type defined as @c SId in the SBML specifications).  The whitespace between
 * <span class="code" style="background-color: #d0d0ee">number</span>
 * and <span class="code" style="background-color: #edd">unit</span>
 * is optional.
 * @li The Boolean function symbols @c &&, @c ||, @c !, and @c != may be used.
 * @li The @em modulo operation is allowed as the symbol @c @% and 
 * will produce a piecewise function in the MathML.
 * @li All inverse trigonometric functions may be defined in the infix
 * either using @c arc as a prefix or simply @c a; in other words, both
 * @c arccsc and @c acsc are interpreted as the operator @em arccosecant
 * defined in MathML.  (Many functions in the SBML Level&nbsp;1 infix-notation
 * parser implemented by @if clike SBML_parseFormula()@endif@if csharp SBML_parseFormula()@endif@if python libsbml.parseFormula()@endif@if java <code><a href="libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula()</a></code>@endif@~
 * are defined this way as well, but not all.)
 * @li The following expression is parsed as a rational number instead of
 * as a numerical division:
 * <pre style="display: block; margin-left: 25px">
 * (<span class="code" style="background-color: #d0d0ee">integer</span>/<span class="code" style="background-color: #d0d0ee">integer</span>)</pre>
 * No spaces are allowed in this construct; in other words,
 * &quot;<code>(3 / 4)</code>&quot; will be parsed into the MathML
 * <code>&lt;divide&gt;</code> construct rather than a rational number.  The 
 * general number syntax allows you to assign units to a rational number, e.g.,
 * &quot;<code>(3/4) ml</code>&quot;.  (If the string is a division, units
 * are not interpreted in this way.)
 * @li Various settings may be altered by using an L3ParserSettings object
 * in conjunction with the alternative function call
 * @if clike SBML_parseL3FormulaWithSettings()@endif@if csharp SBML_parseL3FormulaWithSettings()@endif@if python libsbml.parseL3FormulaWithSettings()@endif@if java <code><a href="libsbml.html#parseL3FormulaWithSettings(java.lang.String)">libsbml.parseL3FormulaWithSettings()</a></code>@endif@~, including the following:
 * <ul>
 * <li> The function @c log with a single argument (&quot;<code>log(x)</code>&quot;) 
 * can be parsed as <code>log10(x)</code>, <code>ln(x)</code>, or treated
 * as an error based on the settings.
 * <li> Unary minuses may be collapsed or expanded.
 * <li> Parsing of units can be turned on and off.
 * <li> The string @c avogadro can be parsed as a MathML @em csymbol or
 * as an identifier.
 * <li> A Model object may optionally be provided to the parser using
 * the variant function call @if clike  SBML_parseL3FormulaWithModel()@endif@if csharp  SBML_parseL3FormulaWithModel()@endif@if python  libsbml.SBML_parseL3FormulaWithModel()@endif@if java  SBML_parseL3FormulaWithModel()@endif@~.
 * When this is done, identifiers (values of type @c SId) from that model
 * are used in preference to pre-defined MathML definitions.  More
 * precisely, the Model entities whose identifiers will shadow identical
 * symbols in the mathematical formula are: Species, Compartment,
 * Parameter, Reaction, and SpeciesReference.  For instance, if the parser
 * is given a Model containing a Species with the identifier
 * &quot;<code>pi</code>&quot;, and the formula to be parsed is
 * &quot;<code>3*pi</code>&quot;, the MathML produced will contain the
 * construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the
 * construct <code>&lt;pi/&gt;</code>.
 * <li> Similarly, when a Model object is provided, @c SId values of
 * user-defined functions present in the model will be used preferentially
 * over pre-defined MathML functions.  For example, if the passed-in Model
 * contains a FunctionDefinition with the identifier
 * &quot;<code>sin</code>&quot;, that function will be used instead of the
 * predefined MathML function <code>&lt;sin/&gt;</code>.
 * </ul>
 * These configuration settings cannot be changed using @em this function
 * (i.e., @if clike SBML_parseL3Formula()@endif@if csharp SBML_parseL3Formula()@endif@if python libsbml.parseL3Formula()@endif@if java <code><a href="libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula()</a></code>@endif@~), 
 * but they can be change on a per-call basis by using the alternative function 
 * @if clike SBML_parseL3FormulaWithSettings()@endif@if csharp SBML_parseL3FormulaWithSettings()@endif@if python libsbml.parseL3FormulaWithSettings()@endif@if java <code><a href="libsbml.html#parseL3FormulaWithSettings(java.lang.String)">libsbml.parseL3FormulaWithSettings()</a></code>@endif@~
 *
 * This function returns the root node of the AST corresponding to the
 * formula given as the argument.  If the formula contains a syntax error,
 * this function will return @c NULL instead.  When @c NULL is returned, an
 * error is set; information about the error can be retrieved using
 * @if clike SBML_getLastParseL3Error()@endif@if csharp SBML_getLastParseL3Error()@endif@if python libsbml.getLastParseL3Error()@endif@if java <code><a href="libsbml.html#getLastParseL3Error(java.lang.String)">libsbml.getLastParseL3Error()</a></code>@endif@~.
 *
 * Note that this facility and the SBML Level&nbsp;1-based @if clike SBML_parseFormula()@endif@if csharp SBML_parseFormula()@endif@if python libsbml.parseFormula()@endif@if java <code><a href="libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula()</a></scode>@endif@~
 * are provided as a convenience by libSBML&mdash;the MathML standard does not
 * actually define a "string-form" equivalent to MathML expressions, so the
 * choice of formula syntax is arbitrary.  The approach taken by libSBML is
 * to start with the syntax defined by SBML Level&nbsp;1 (which in fact
 * used a text-string representation of formulas, and not MathML), and
 * expand it to include the above functionality.  This formula syntax is
 * based mostly on C programming syntax, and may contain operators,
 * function calls, symbols, and white space characters.  The following
 * table provides the precedence rules for the different entities that may
 * appear in formula strings.
 *
 * @htmlinclude math-precedence-table-l3.html
 * 
 * In the table above, @em operand implies the construct is an operand, @em
 * prefix implies the operation is applied to the following arguments, @em
 * unary implies there is one argument, and @em binary implies there are
 * two arguments.  The values in the <b>Precedence</b> column show how the
 * order of different types of operation are determined.  For example, the
 * expression <code>a + b * c</code> is evaluated as <code>a + (b * c)</code> 
 * because the @c * operator has higher precedence.  The
 * <b>Associates</b> column shows how the order of similar precedence
 * operations is determined; for example, <code>a && b || c</code> is
 * evaluated as <code>(a && b) || c</code> because the @c && and @c ||
 * operators are left-associative and have the same precedence.
 *
 * The function call syntax consists of a function name, followed by optional
 * white space, followed by an opening parenthesis token, followed by a
 * sequence of zero or more arguments separated by commas (with each comma
 * optionally preceded and/or followed by zero or more white space
 * characters), followed by a closing parenthesis token.  The function name
 * must be chosen from one of the pre-defined functions in SBML or a
 * user-defined function in the model.  The following table lists the names
 * of certain common mathematical functions; this table corresponds to
 * Table&nbsp;6 in the <a target="_blank" href="http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2">SBML Level&nbsp;1 Version&nbsp;2 specification</a> with additions based on the 
 * functions added in SBML Level 2 and Level 3:
 *
 * @htmlinclude string-functions-table-l3.html
 *
 * Note that this function's interpretation of the string
 * &quot;<code>log</code>&quot; as a function with a single argument can be
 * changed; use the function @if clike SBML_parseL3FormulaWithSettings()@endif@if csharp SBML_parseL3FormulaWithSettings()@endif@if python libsbml.parseL3FormulaWithSettings()@endif@if java <code><a href="libsbml.html#parseL3FormulaWithSettings(java.lang.String)">libsbml.parseL3FormulaWithSettings()</a></code>@endif@~
 * instead of this function and pass it an appropriate L3ParserSettings
 * object.  By default, unlike the SBML Level&nbsp;1 parser implemented by
 * @if clike SBML_parseFormula()@endif@if csharp SBML_parseFormula()@endif@if python libsbml.parseFormula()@endif@if java <code><a href="libsbml.html#parseFormula(java.lang.String)">libsbml.parseFormula()</a></code>@endif@~, 
 * the string &quot;<code>log</code>&quot; is interpreted as the base&nbsp;10
 * logarithm, and @em not as the natural logarithm.  However, you can change
 * the interpretation to be base-10 log, natural log, or as an error; since
 * the name "log" by itself is ambiguous, you require that the parser uses
 * @c log10 or @c ln instead, which are more clear.  Please refer to
 * @if clike SBML_parseL3FormulaWithSettings()@endif@if csharp SBML_parseL3FormulaWithSettings()@endif@if python libsbml.parseL3FormulaWithSettings()@endif@if java <code><a href="libsbml.html#parseL3FormulaWithSettings(java.lang.String)">libsbml.parseL3FormulaWithSettings()</a></code>@endif@~.
 * 
 * In addition, the following symbols will be translated to their MathML
 * equivalents, if no symbol with the same @c SId identifier string exists
 * in the Model object provided:
 *
 * @htmlinclude string-values-table-l3.html
 * 
 * Note that whether the string &quot;<code>avogadro</code>&quot; is parsed
 * as an AST node of type @c AST_NAME_AVOGADRO or @c AST_NAME is
 * configurable; use the alternate version of this function, called
 * @if clike SBML_parseL3FormulaWithSettings()@endif@if csharp SBML_parseL3FormulaWithSettings()@endif@if python libsbml.parseL3FormulaWithSettings()@endif@if java <code><a href="libsbml.html#parseL3FormulaWithSettings(java.lang.String)">libsbml.parseL3FormulaWithSettings()</a></code>@endif@~.
 * This functionality is provided because SBML Level&nbsp;2 models may not
 * use @c AST_NAME_AVOGADRO AST nodes.
 *
 * @param formula the text-string formula expression to be parsed
 *
 * @return the root node of an AST representing the mathematical formula,
 * or @c NULL if an error occurred while parsing the formula.  When @c NULL
 * is returned, an error is recorded internally; information about the
 * error can be retrieved using 
 * @if clike SBML_getLastParseL3Error()@endif@if csharp SBML_getLastParseL3Error()@endif@if python libsbml.getLastParseL3Error()@endif@if java <code><a href="libsbml.html#getLastParseL3Error(java.lang.String)">libsbml.getLastParseL3Error()</a></code>@endif@~.
 *
 * @if clike @see SBML_getLastParseL3Error()@endif@~
 * @if csharp @see SBML_getLastParseL3Error()@endif@~
 * @if python @see libsbml.getLastParseL3Error()@endif@~
 * @if java @see SBML_getLastParseL3Error()@endif@~
 * @if clike @see SBML_formulaToString()@endif@~
 * @if csharp @see SBML_formulaToString()@endif@~
 * @if python @see libsbml.formulaToString()@endif@~
 * @if java @see formulaToString()@endif@~
 * @if clike @see SBML_parseL3FormulaWithModel()@endif@~
 * @if csharp @see SBML_parseL3FormulaWithModel()@endif@~
 * @if python @see libsbml.parseL3FormulaWithModel()@endif@~
 * @if java @see SBML_parseL3FormulaWithModel()@endif@~
 * @if clike @see SBML_parseL3FormulaWithSettings()@endif@~
 * @if csharp @see SBML_parseL3FormulaWithSettings()@endif@~
 * @if python @see libsbml.parseL3FormulaWithSettings()@endif@~
 * @if java @see SBML_parseL3FormulaWithSettings()@endif@~
 */
LIBSBML_EXTERN
ASTNode_t *
SBML_parseL3Formula (const char *formula)
{
  if (l3p==NULL) {
    l3p = new L3Parser();
  }
  L3ParserSettings l3ps = l3p->getDefaultL3ParserSettings();
  return SBML_parseL3FormulaWithSettings(formula, &l3ps);
}


/**
 * Parses the given mathematical formula using specific a specific Model to
 * resolve symbols, and returns an Abstract Syntax Tree (AST)
 * representation of the result.
 *
 * This is identical to
 * @if clike SBML_parseL3Formula()@endif@if csharp SBML_parseL3Formula()@endif@if python libsbml.parseL3Formula()@endif@if java <code><a href="libsbml.html#parseL3Formula(org.sbml.libsbml.ASTNode)">libsbml.parseL3Formula()</a></code>@endif@~,
 * except that this function uses the given model in the argument @p model
 * to check against identifiers that appear in the @p formula.
 *
 * For more details about the parser, please see the definition of
 * the function SBML_parseL3Formula().
 *
 * @param formula the mathematical formula expression to be parsed
 * @param model the Model object to use for checking identifiers
 *
 * @return the root node of an AST representing the mathematical formula,
 * or @c NULL if an error occurred while parsing the formula.  When @c NULL
 * is returned, an error is recorded internally; information about the
 * error can be retrieved using
 * @if clike SBML_getLastParseL3Error()@endif@if csharp SBML_getLastParseL3Error()@endif@if python libsbml.getLastParseL3Error()@endif@if java <code><a href="libsbml.html#getLastParseL3Error(java.lang.String)">libsbml.getLastParseL3Error()</a></code>@endif@~.
 * 
 * @if clike @see SBML_getLastParseL3Error()@endif@~
 * @if csharp @see SBML_getLastParseL3Error()@endif@~
 * @if python @see libsbml.getLastParseL3Error()@endif@~
 * @if java @see SBML_getLastParseL3Error()@endif@~
 * @if clike @see SBML_parseL3Formula()@endif@~
 * @if csharp @see SBML_parseL3Formula()@endif@~
 * @if python @see libsbml.parseL3Formula()@endif@~
 * @if java @see SBML_parseL3Formula()@endif@~
 * @if clike @see SBML_parseL3FormulaWithSettings()@endif@~
 * @if csharp @see SBML_parseL3FormulaWithSettings()@endif@~
 * @if python @see libsbml.parseL3FormulaWithSettings()@endif@~
 * @if java @see SBML_parseL3FormulaWithSettings()@endif@~
 */
LIBSBML_EXTERN
ASTNode_t *
SBML_parseL3FormulaWithModel (const char *formula, const Model_t * model)
{
  if (l3p==NULL) {
    l3p = new L3Parser();
  }
  L3ParserSettings l3ps = l3p->getDefaultL3ParserSettings();
  l3ps.setModel(model);
  return SBML_parseL3FormulaWithSettings(formula, &l3ps);
}


/**
 * Parses the given mathematical formula using specific parser settings and
 * returns an Abstract Syntax Tree (AST) representation of the result.
 *
 * This is identical to
 * @if clike SBML_parseL3Formula()@endif@if csharp SBML_parseL3Formula()@endif@if python libsbml.parseL3Formula()@endif@if java <code><a href="libsbml.html#parseL3Formula(org.sbml.libsbml.ASTNode)">libsbml.parseL3Formula()</a></code>@endif@~,
 * except that this function uses the parser settings given in the argument
 * @p settings.  The settings override the default parsing behavior.
 *
 * The parameter @p settings allows callers to change the following parsing
 * behaviors:
 *
 * @li Use a specific Model object against which identifiers to compare
 * identifiers.  This causes the parser to search the Model for identifiers
 * that the parser encounters in the formula.  If a given symbol in the
 * formula matches the identifier of a Species, Compartment, Parameter,
 * Reaction, SpeciesReference or FunctionDefinition in the Model, then the
 * symbol is assumed to refer to that model entity instead of any possible
 * mathematical terms with the same symbol.  For example, if the parser is
 * given a Model containing a Species with the identifier
 * &quot;<code>pi</code>&quot;, and the formula to be parsed is
 * &quot;<code>3*pi</code>&quot;, the MathML produced will contain the
 * construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the
 * construct <code>&lt;pi/&gt;</code>.
 * @li Whether to parse &quot;<code>log(x)</code>&quot; with a single
 * argument as the base 10
 * logarithm of x, the natural logarithm of x, or treat the case as an
 * error.
 * @li Whether to parse &quot;<code>number id</code>&quot; by interpreting
 * @c id as the identifier of a unit of measurement associated with the
 * number, or whether to treat the case as an error.
 * @li Whether to parse &quot;<code>avogadro</code>&quot; as an ASTNode of
 * type @c AST_NAME_AVOGADRO or as type @c AST_NAME.
 * @li Whether to always create explicit ASTNodes of type @c AST_MINUS for
 * all unary minuses, or collapse them when possible.
 *
 * For more details about the parser, please see the definition of
 * L3ParserSettings and @if clike SBML_parseL3Formula()@endif@if csharp SBML_parseL3Formula()@endif@if python libsbml.parseL3Formula()@endif@if java <code><a href="libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula()</a></code>@endif@~.
 *
 * @param formula the mathematical formula expression to be parsed
 * @param settings the settings to be used for this parser invocation
 *
 * @return the root node of an AST representing the mathematical formula,
 * or @c NULL if an error occurred while parsing the formula.  When @c NULL
 * is returned, an error is recorded internally; information about the
 * error can be retrieved using
 * @if clike SBML_getLastParseL3Error()@endif@if csharp SBML_getLastParseL3Error()@endif@if python libsbml.getLastParseL3Error()@endif@if java <code><a href="libsbml.html#getLastParseL3Error(java.lang.String)">libsbml.getLastParseL3Error()</a></code>@endif@~.
 * 
 * @if clike @see SBML_getLastParseL3Error()@endif@~
 * @if csharp @see SBML_getLastParseL3Error()@endif@~
 * @if python @see libsbml.getLastParseL3Error()@endif@~
 * @if java @see SBML_getLastParseL3Error()@endif@~
 * @if clike @see SBML_parseL3Formula()@endif@~
 * @if csharp @see SBML_parseL3Formula()@endif@~
 * @if python @see libsbml.parseL3Formula()@endif@~
 * @if java @see SBML_parseL3Formula()@endif@~
 * @if clike @see SBML_parseL3FormulaWithModel()@endif@~
 * @if csharp @see SBML_parseL3FormulaWithModel()@endif@~
 * @if python @see libsbml.parseL3FormulaWithModel()@endif@~
 * @if java @see SBML_parseL3FormulaWithModel()@endif@~
 */
LIBSBML_EXTERN
ASTNode_t *
SBML_parseL3FormulaWithSettings (const char *formula, const L3ParserSettings_t * settings)
{
  if (l3p==NULL) {
    l3p = new L3Parser();
  }
  l3p->clear();
  l3p->setInput(formula);
  l3p->model = settings->getModel();
  l3p->parselog = settings->getParseLog();
  l3p->collapseminus = settings->getParseCollapseMinus();
  l3p->parseunits = settings->getParseUnits();
  l3p->avocsymbol = settings->getParseAvogadroCsymbol();
  sbml_yyparse();
  return l3p->outputNode;
}


/**
 * Returns a copy of the default parser settings used by @if clike SBML_parseL3Formula()@endif@if csharp SBML_parseL3Formula()@endif@if python libsbml.parseL3Formula()@endif@if java <code><a href="libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula()</a></code>@endif@~.
 * 
 * The settings structure allows callers to change the following parsing
 * behaviors:
 * 
 * @li Use a specific Model object against which identifiers to compare
 * identifiers.  This causes the parser to search the Model for identifiers
 * that the parser encounters in the formula.  If a given symbol in the
 * formula matches the identifier of a Species, Compartment, Parameter,
 * Reaction, SpeciesReference or FunctionDefinition in the Model, then the
 * symbol is assumed to refer to that model entity instead of any possible
 * mathematical terms with the same symbol.  For example, if the parser is
 * given a Model containing a Species with the identifier
 * &quot;<code>pi</code>&quot;, and the formula to be parsed is
 * &quot;<code>3*pi</code>&quot;, the MathML produced will contain the
 * construct <code>&lt;ci&gt; pi &lt;/ci&gt;</code> instead of the
 * construct <code>&lt;pi/&gt;</code>.
 * @li Whether to parse &quot;<code>log(x)</code>&quot; with a single
 * argument as the base 10
 * logarithm of x, the natural logarithm of x, or treat the case as an
 * error.
 * @li Whether to parse &quot;<code>number id</code>&quot; by interpreting
 * @c id as the identifier of a unit of measurement associated with the
 * number, or whether to treat the case as an error.
 * @li Whether to parse &quot;<code>avogadro</code>&quot; as an ASTNode of
 * type @c AST_NAME_AVOGADRO or as type @c AST_NAME.
 * @li Whether to always create explicit ASTNode objects of type @c AST_MINUS
 * for all unary minus operators in a formula, or collapse them when possible.
 *
 * For more details about the parser, please see the definition of
 * L3ParserSettings and @if clike SBML_parseL3Formula()@endif@if csharp SBML_parseL3Formula()@endif@if python libsbml.parseL3Formula()@endif@if java <code><a href="libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula()</a></code>@endif@~.
 * 
 * @if clike @see SBML_parseL3Formula()@endif@~
 * @if csharp @see SBML_parseL3Formula()@endif@~
 * @if python @see libsbml.parseL3Formula()@endif@~
 * @if java @see SBML_parseL3Formula()@endif@~
 * @if clike @see SBML_parseL3FormulaWithModel()@endif@~
 * @if csharp @see SBML_parseL3FormulaWithModel()@endif@~
 * @if python @see libsbml.parseL3FormulaWithModel()@endif@~
 * @if java @see SBML_parseL3FormulaWithModel()@endif@~
 * @if clike @see SBML_parseL3FormulaWithSettings()@endif@~
 * @if csharp @see SBML_parseL3FormulaWithSettings()@endif@~
 * @if python @see libsbml.parseL3FormulaWithSettings()@endif@~
 * @if java @see SBML_parseL3FormulaWithSettings()@endif@~
 */
LIBSBML_EXTERN
L3ParserSettings_t* 
SBML_getDefaultL3ParserSettings ()
{
  if (l3p==NULL) {
    l3p = new L3Parser();
  }
  return new L3ParserSettings(l3p->getDefaultL3ParserSettings());
}

/**
 * Returns the last error reported by the parser.
 *
 * If @if clike SBML_parseL3Formula()@endif@if csharp SBML_parseL3Formula()@endif@if python libsbml.parseL3Formula()@endif@if java <code><a href="libsbml.html#parseL3Formula(java.lang.String)">libsbml.parseL3Formula()</a></code>@endif@~, 
 * @if clike SBML_parseL3FormulaWithSettings()@endif@if csharp SBML_parseL3FormulaWithSettings()@endif@if python libsbml.parseL3FormulaWithSettings()@endif@if java <code><a href="libsbml.html#parseL3FormulaWithSettings(java.lang.String)">libsbml.parseL3FormulaWithSettings()</a></code>@endif@~, or
 * @if clike SBML_parseL3FormulaWithModel()@endif@if csharp SBML_parseL3FormulaWithModel()@endif@if python libsbml.parseL3FormulaWithModel()@endif@if java <code><a href="libsbml.html#parseL3FormulaWithModel(java.lang.String)">libsbml.parseL3FormulaWithModel()</a></code>@endif@~ return @c NULL, an error is set internally which is accessible
 * via this function. 
 *
 * @return a string describing the error that occurred.  This will contain
 * the string the parser was trying to parse, which character it had parsed
 * when it encountered the error, and a description of the error.
 *
 * @if clike @see SBML_parseL3Formula()@endif@~
 * @if csharp @see SBML_parseL3Formula()@endif@~
 * @if python @see libsbml.parseL3Formula()@endif@~
 * @if java @see SBML_parseL3Formula()@endif@~
 * @if clike @see SBML_parseL3FormulaWithModel()@endif@~
 * @if csharp @see SBML_parseL3FormulaWithModel()@endif@~
 * @if python @see libsbml.parseL3FormulaWithModel()@endif@~
 * @if java @see SBML_parseL3FormulaWithModel()@endif@~
 * @if clike @see SBML_parseL3FormulaWithSettings()@endif@~
 * @if csharp @see SBML_parseL3FormulaWithSettings()@endif@~
 * @if python @see libsbml.parseL3FormulaWithSettings()@endif@~
 * @if java @see SBML_parseL3FormulaWithSettings()@endif@~
 */
LIBSBML_EXTERN
char*
SBML_getLastParseL3Error()
{
  if (l3p==NULL) {
    l3p = new L3Parser();
  }
  return safe_strdup(l3p->getError().c_str());
}
/** @endcond */ //C-only documentation bit.

END_C_DECLS
LIBSBML_CPP_NAMESPACE_END
