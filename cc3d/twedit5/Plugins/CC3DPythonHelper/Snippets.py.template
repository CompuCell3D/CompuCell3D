===============  # @Menu@ Python Utilities

----------  # @Submenu@ Open File In Simulation Output Directory
from pathlib import Path

if self.output_dir is not None:
    output_path = Path(self.output_dir).joinpath("<FILE_NAME>")
    # create folder to store data
    output_path.parent.mkdir(parents=True, exist_ok=True)
    try:
        file_handle = open(output_path, 'w')
    except IOError:
        print ("Could not open file for writing.")
        return

----------  # @Submenu@ Fetch Steppable By Class Name
self.getSteppableByClassName('STEPPABLE_CLASS_NAME')

----------  # @Submenu@ Get Dir Of Current File
fileDir = os.path.dirname(os.path.abspath(__file__))

----------  # @Submenu@ Get FullPath Of Current File
filePath = os.path.abspath(__file__)

----------  # @Submenu@ Import os
import os

----------  # @Submenu@ Set Simulation Output Directory (main Python script)
# It is best to call this function from __init__ of first registered steppable
self.set_output_dir(output_dir="<CUSTOM_OUTPUT_DIR>", abs_path=False)

===============  # @Menu@ SBML Solver

----------  # @Submenu@ 1. Model Initial Data
# this can be e.g. partial path 'Simulation/osci.sbml'
model_file = 'PATH_TO_SBML_MODEL'

initial_conditions = {}
initial_conditions['SPECIES_NAME1'] = species_val1
initial_conditions['SPECIES_NAME2'] = species_val2

step_size = 0.5

----------  # @Submenu@ 2. Add model to cell ids
self.add_sbml_to_cell_ids(model_file=model_file, model_name='MODEL_NAME', cell_ids=[1, 3, 7], step_size=step_size,
                          initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add model to cell types
self.add_sbml_to_cell_types(model_file=model_file, model_name='MODEL_NAME', cell_types=[self.CELLTYPENAME1, self.CELLTYPENAME1],
                        step_size=step_size, initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add model to individual cell
cell_20 = self.fetch_cell_by_id(20)

if cell_20:
    self.add_sbml_to_cell(model_file=model_file, model_name='MODEL_NAME', cell=cell_20,step_size=step_size,
                          initial_conditions=initial_conditions)


----------  # @Submenu@ 2. Add free floating model e.g. PBPK
self.add_free_floating_sbml(model_file=model_file, model_name='UNIQUE_MODEL_NAME', step_size=step_size,
                            initial_conditions=initial_conditions)

----------  # @Submenu@ 3. Timestep SBML models
self.timestep_sbml()

----------  # @Submenu@ 5. Copy select SBMLs
self.copy_sbml_simulators(from_cell=source_cell, to_cell=target_cell, sbml_names=['MODEL_NAME1', 'MODEL_NAME2'])

----------  # @Submenu@ 5. Copy All SBMLs
self.copy_sbml_simulators(from_cell=source_cell, to_cell=target_cell)

----------  # @Submenu@  Get SBML State for individual cell
# returns dictionary of values
state = cell.sbml.MODELNAME


----------  # @Submenu@  Get SBML State for Free Floating model
state = self.sbml.UNIQUE_MODEL_NAME

----------  # @Submenu@  Get SBML Value for SBML in a specific cell
# value name can be e.g. species name
# example cell.DN.Delta
cell.sbml.MODEL_NAME['VALUE_NAME']

----------  # @Submenu@  Get SBML Value for Free Floating model
# value name can be e.g. species name
self.sbml.MODEL_NAME['VALUE_NAME']

----------  # @Submenu@  Get SBML Simulator for individual cell(advanced)
# example cell.sbml._rr_DN
cell.sbml._rr_MODEL_NAME

----------  # @Submenu@  Get SBML Simulator for Free Floating Model(advanced)
# example self.sbml._rr_DN
self.sbml._rr_MODEL_NAME

----------  # @Submenu@  Set SBML State for individual cell
state = {}
state['REACTANT_NAME'] = 0.9

self.set_sbml_state(model_name='MODELNAME', cell=cell, state=state)

----------  # @Submenu@  Set SBML State for Free Floating model
state = {}
state['REACTANT_NAME'] = 0.9
self.set_sbml_state(model_name='MODELNAME',  state=state)

----------  # @Submenu@  Set SBML Value for SBML in a specific cell
# value name can be e.g. species name
cell.sbml.UNIQUE_MODEL_NAME['VALUE_NAME'] = 0.1

----------  # @Submenu@  Set SBML Value for Free Floating model
# value name can be e.g. species name
self.sbml.UNIQUE_MODEL_NAME['VALUE_NAME'] = 0.1

----------  # @Submenu@  Delete SBML from cell ids
self.delete_sbml_from_cell_ids(model_name='MODEL_NAME', cell_ids=[1, 4, 7])

----------  # @Submenu@  Delete SBML from cell types
self.delete_sbml_from_cell_types(model_name='MODEL_NAME', cell_types=[self.CELLTYPE1, self.CELLTYPE2])

----------  # @Submenu@  Delete SBML from individual cell
self.delete_sbml_from_cell(model_name='MODEL_NAME', cell=cell)

----------  # @Submenu@  Delete Free Floating SBML
self.delete_free_floating_sbml(model_name='UNIQUE_MODEL_NAME')

----------  # @Submenu@  Set SBML Integrator  Global Options
# adding options that setup SBML solver integrator - these are optional but useful when encountering
# integration instabilities
# relative is relative tolerance, absolute is absolute tolerance,
# steps is the initial number of integration steps for each integration interval
# (higher number does not result in slower simulation, quite to the contrary),
# stiff set to true will use stiff ODE solver
options = {'relative': 1e-10, 'absolute': 1e-12, 'steps': 10, 'stiff': False}
self.set_sbml_global_options(options)

----------  # @Submenu@  Get SBML Integrator  Global Options
# returns current options - can be None if no global options were set
options = self.get_sbml_global_options()

===============  # @Menu@ Steering Panel

----------i1  # @Submenu@ 1.Set Up Steering Panel


def add_steering_panel(self):
    self.add_steering_param(name='MY_PARAM_SLIDER', val=20, min_val=0, max_val=100,
                            decimal_precision=2, widget_name='slider')
    self.add_steering_param(name='MY_PARAM_COMBO', val=20, enum=[10,20,30,40,50,60,70,80,90,100],
                                widget_name='combobox')

def process_steering_panel_data(self):
    print ('processing steering panel updates')
    print ('all dirty flag=', self.steering_param_dirty())
    param_slider = self.get_steering_param('MY_PARAM_SLIDER')
    param_combo = self.get_steering_param('MY_PARAM_COMBO')
    print ('updated MY_PARAM_SLIDER=',param_slider)
    print ('updated MY_PARAM_COMBO=', param_combo)

    # IMPORTANT: you may add code here tht updates cell properties based on the
    # values of the parameters from the steering panel. For example:

    # for cell in self.cellList:
    #     cell.targetVolume = param_slider
    #     cell.lambdaVolume = param_combo

----------  # @Submenu@ Get Updated Value of Steering Parameter
my_param = self.get_steering_param('MY_PARAM')

----------  # @Submenu@ Check if Steering Panel Was Updated
updated_flag = self.steering_param_dirty()

===============  # @Menu@ Cell Constraints

----------  # @Submenu@ Change Target Volume
cell.targetVolume = 25

----------  # @Submenu@ Change Lambda Volume
cell.lambdaVolume = 2.0

----------  # @Submenu@ Change Target Surface
cell.targetSurface = 20.0

----------  # @Submenu@ Change Lambda Surface
cell.lambdaSurface = 2.0

----------  # @Submenu@ Apply Force To Cell
# Make sure ExternalPotential plugin is loaded
cell.lambdaVecX = -0.5  # force component pointing along X axis - towards positive X's
cell.lambdaVecY = 0.5  # force component pointing along Y axis - towards negative Y's
cell.lambdaVecZ = 0.0  # force component pointing along Z axis

----------  # @Submenu@ Length Constraint By Cell Id
# Make sure LengthConstraintLocalFlex plugin is loaded
# Argument Order: cell , lambdaLength, targetLength
self.lengthConstraintLocalFlexPlugin.setLengthConstraintData(cell, 20, 20)

----------  # @Submenu@ Connectivity Constraint By Cell Id
# Make sure ConnectivityLocalFlex plugin is loaded
# Argument Order: cell, strength
self.connectivityLocalFlexPlugin.setConnectivityStrength(cell, 10000000)

===============  # @Menu@ Cell Manipulation

----------  # @Submenu@ Fetch Cell By Id
cell = self.fetch_cell_by_id(CELL_ID)

----------  # @Submenu@ Delete Cell
self.delete_cell(cell)

----------  # @Submenu@ Create Cell
# size of cell will be 3x3x1
self.cell_field[10:12, 10:12, 0] = self.new_cell(self.TYPENAME)

----------  # @Submenu@ Create Cell (detailed)
x = X_POSITION
y = Y_POSITION
size = SIZE
cell = self.new_cell(self.TYPENAME)
# size of cell will be SIZExSIZEx1
self.cell_field[x:x + size - 1, y:y + size - 1, 0] = cell

----------  # @Submenu@ Get Cell At a Pixel
cell = self.cell_field[10, 11, 0]

----------  # @Submenu@ Move Cell
# Shifting entire cell by a 'shiftVector'         
shift_vector = [20, 20, 0]
self.move_cell(cell, shift_vector)

===============  # @Menu@ Distances, Vectors, Transformations

----------  # @Submenu@ Distance Vector Between Cells
vec = self.distance_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance Vector Between Cells (Invariant)
vec = self.invariant_distance_vector_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance  Between Cells
vec = self.distance_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance  Between Cells (Invariant)
vec = self.invariant_distance_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance Vector Between Points
vec = self.distance(p1=[10, 10, 0], p2=[11, 11, 0])

----------  # @Submenu@ Distance Vector Between Points (Invariant)
vec = self.invariant_distance_vector(p1=[10, 10, 0], p2=[11, 11, 0])

----------  # @Submenu@ Distance Vector Between Points (Invariant, Integer)
vec = self.invariant_distance_vector_integer(p1=[10, 10, 0], p2=[11, 11, 0])

----------  # @Submenu@ Vector Norm
norm = self.vector_norm(VECTOR)

----------  # @Submenu@ Hex: Hex 2 Cartesian
# returns Point3D
pt = self.hex_2_cartesian(coords=COORDS)

----------  # @Submenu@ Hex: Cartesian 2 Hex
# retutns Coordinates<double>
coords = self.cartesian_2_hex(coords=POINT3D)

----------  # @Submenu@ Numpy: Point3D To Numpy Array
ptArray = self.point_3d_to_numpy(PT)

----------  # @Submenu@ Numpy: Numpy Array To Point3D
pt = self.numpy_to_point_3d(PT_ARRAY)

----------  # @Submenu@ Hex: Cartesian 2 Hex
coords = self.cartesian_2_hex(coords=POINT3D)  # retutns Coordinates<double>

===============  # @Menu@ Visit

----------  # @Submenu@ All Cells
# iterating over all cells in simulation        
for cell in self.cell_list:
    # you can access/manipulate cell properties here
    print("id=", cell.id, " type=", cell.type, " volume=", cell.volume)

----------  # @Submenu@ All Cells Of Given Type
# iterating over cells of type 1
# list of  cell types (capitalized)
for cell in self.cell_list_by_type(self.TYPENAME_1, self.TYPENAME_2, ...):
    # you can access/manipulate cell properties here
    print ("id=", cell.id, " type=", cell.type)

----------  # @Submenu@ Cell Neighbors
for neighbor, common_surface_area in self.get_cell_neighbor_data_list(cell):
    if neighbor:
        print("neighbor.id", neighbor.id, " commonSurfaceArea=", common_surface_area)
    else:
        print("Medium commonSurfaceArea=", common_surface_area)

----------  # @Submenu@ Cell Boundary Pixels
# Make sure BoundaryPixelTracker plugin is loaded
pixel_list = self.get_cell_boundary_pixel_list(cell)
for boundary_pixel_tracker_data in pixel_list:
    print("pixel of cell id=", cell.id, " type:", cell.type, " = ",
          boundary_pixel_tracker_data.pixel, " number of pixels=", pixel_list.numberOfPixels())

----------  # @Submenu@ Cell Pixels
# Make sure PixelTracker plugin is loaded
pixel_list = self.get_cell_pixel_list(cell)
for pixel_tracker_data in pixel_list:
    print("pixel of cell id=", cell.id, " type:", cell.type, " = ", pixel_tracker_data.pixel,
          " number of pixels=", pixel_list.numberOfPixels())

----------  # @Submenu@ All Lattice Pixels
for x, y, z in self.every_pixel():
    print("x,y,z=", (x, y, z))

----------  # @Submenu@ All Clusters
for compartments in self.clusters:
    print('compartments=', compartments)

----------  # @Submenu@ All Clusters and Cells Withing Clusters
for compartments in self.clusters:
    for cell in compartments:
        print(cell.id)

===============  # @Menu@ Chemical Field Manipulation

----------  # @Submenu@ Get Field Reference
field = self.field.FIELD_NAME

----------  # @Submenu@ Get Field Min Value
minValue = field.min()

----------  # @Submenu@ Get Field Max Value
maxValue = field.max()

----------  # @Submenu@ Get Field Value
value = field[10, 10, 0]

----------  # @Submenu@ Set Field Value
field[10, 10, 0] = 1.02

----------  # @Submenu@ Write To Disk

field = self.field.FIELD_NAME
output_dir = self.output_dir


if output_dir is not None:
    output_path = Path(output_dir).joinpath(FILE_NAME)
    # create folder to store data
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'w') as file_handle:
        for i, j, k in self.every_pixel():
            file_handle.write("%d\t%d\t%d\t%f\n" % (i, j, k, field[i, j, k]))

----------  # @Submenu@ Modification (aka secretion)
field = self.field.FIELD_NAME
if field:
    for i, j, k in self.every_pixel():
        field[i, j, k] = i * j

===============  # @Menu@ Cell Attributes

----------  # @Submenu@ Check If Two Cells Are Different
self.are_cells_different(cell1, cell2)

----------  # @Submenu@ Access/Modify Dictionary Attribute
# access/modification of a dictionary attached to cell - make sure to declare in main script that
# you will use such attribute
cell.dict['ATTR_NAME'] = VALUE_OR_OBJECT

----------  # @Submenu@ Center Of Mass
# Make sure CenterOfMass plugin is loaded
# READ ONLY ACCESS
xCOM = cell.xCOM
yCOM = cell.yCOM
zCOM = cell.zCOM

----------  # @Submenu@ Volume
# READ ONLY ACCESS        
volume = cell.volume

----------  # @Submenu@ Target Volume
# READ/WRITE  ACCESS                
target_volume = cell.targetVolume

----------  # @Submenu@ Lambda Volume
# READ/WRITE  ACCESS        
lambda_volume = cell.lambdaVolume

----------  # @Submenu@ Surface
# READ ONLY ACCESS        
surface = cell.surface

----------  # @Submenu@ Target Surface
# READ/WRITE  ACCESS                
target_surface = cell.targetSurface

----------  # @Submenu@ Lambda Surface
# READ/WRITE  ACCESS        
lambda_surface = cell.lambdaSurface

----------  # @Submenu@ Id
# READ ONLY ACCESS        
id = cell.id

----------  # @Submenu@ Cluster Id
# READ ONLY ACCESS - can be modified using reassignClusterId function        
cluster_id = cell.clusterId

----------  # @Submenu@ Cluster Id Reassignment
# You cannot simply set cluster Id on a cell to make t belong to other cluster you
# have to use the following function call
# changing cluster id to 1536 for cell 'cell'
self.reassign_cluster_id(cell, 1536)

----------  # @Submenu@ Cell Type
# READ/WRITE  ACCESS                
cell_type = cell.type

----------  # @Submenu@ Fluctuation Ampl
# READ/WRITE  ACCESS                        
fluct_ampl = cell.fluctAmpl

----------  # @Submenu@ Fluctuation Ampl Reassignment
cell.fluctAmpl = 50
# uncomment line below to use globally defined FluctuationAmplitude
# cell.fluctAmpl=-1

----------  # @Submenu@ Inertia Tensor
# READ ONLY ACCESS        
iXX = cell.iXX
iYY = cell.iYY
iZZ = cell.iZZ
iXY = cell.iXY
iXZ = cell.iXZ
iYZ = cell.iYZ
eccentricity = cell.ecc

===============  # @Menu@ Focal Point Placticity

----------  # @Submenu@ Properties
# Make sure FocalPointPlasticity plugin is loaded
# visiting all focal links cell 'cell' has with other cells
for fppd in self.get_focal_point_plasticity_data_list(cell):
    print("fppd.neighborId", fppd.neighborAddress.id, " lambda=", fppd.lambdaDistance,
           " targetDistance=", fppd.targetDistance)

    # arguments are (cell1,cell2,lambda,targetDistance,maxDistance)
    self.focalPointPlasticityPlugin.setFocalPointPlasticityParameters(cell, fppd.neighborAddress, 1.0, 7.0, 20.0)

----------  # @Submenu@ Properties (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
# visiting all focal links cell 'cell' has with other cells
for fppd in self.get_internal_focal_point_plasticity_data_list(cell):
    print("fppd.neighborId", fppd.neighborAddress.id, " lambda=", fppd.lambdaDistance,
          " targetDistance=", fppd.targetDistance)

    # arguments are (cell1,cell2,lambda,targetDistance,maxDistance)
    self.focalPointPlasticityPlugin.setInternalFocalPointPlasticityParameters(cell, fppd.neighborAddress, 1.0, 7.0,
                                                                              20.0)

----------  # @Submenu@ Create FPP Link
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.createFocalPointPlasticityLink(CELL1, CELL2, LAMBDA, TARGET_DISTANCE, MAX_DISTANCE)

----------  # @Submenu@ Create FPP Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.createInternalFocalPointPlasticityLink(CELL1, CELL2, LAMBDA, TARGET_DISTANCE,
                                                                       MAX_DISTANCE)

----------  # @Submenu@ Get Lambda for FPP Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.getPlasticityParametersLambdaDistance(CELL1, CELL2)

----------  # @Submenu@ Get Target Distance for FPP Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.getPlasticityParametersTargetDistance(CELL1, CELL2)

----------  # @Submenu@ Delete FPP Link
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.deleteFocalPointPlasticityLink(CELL1, CELL2)

----------  # @Submenu@ Delete FPP Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.deleteInternalFocalPointPlasticityLink(CELL1, CELL2)

----------  # @Submenu@ Create Anchor
# Make sure FocalPointPlacticity plugin is loaded
anchorId = self.focalPointPlasticityPlugin.createAnchor(CELL, LAMBDA, TARGET_DISTANCE, MAX_DISTANCE, ANCHOR_X, ANCHOR_Y,
                                                        ANCHOR_Z)

----------  # @Submenu@ Delete Anchor
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.deleteAnchor(CELL, ANCHOR_ID)

----------  # @Submenu@ Set Anchor Parameters
self.focalPointPlasticityPlugin.setAnchorParameters(CELL, ANCHOR_ID, LAMBDA, TARGET_DISTANCE, MAX_DISTANCE, ANCHOR_X,
                                                    ANCHOR_Y, ANCHOR_Z)

===============  # @Menu@ Adhesion Flex

----------  # @Submenu@ Get Molecule Dens. By Name
# Make sure AdhesionFlex plugin is loaded
# accessing adhesion molecule density using its name
self.adhesionFlexPlugin.getAdhesionMoleculeDensity(cell, "NCad")

----------  # @Submenu@ Get Molecule Dens. By Index
# Make sure AdhesionFlex plugin is loaded
# accessing adhesion molecule density using its index
# molecules are indexed in the same order they are listed in the xml file
self.adhesionFlexPlugin.getAdhesionMoleculeDensity(cell,0)

----------  # @Submenu@ Set Molecule Dens. By Name
# Make sure AdhesionFlex plugin is loaded
# setting adhesion molecule density using its name
self.adhesionFlexPlugin.setAdhesionMoleculeDensity(cell, "NCad", 11.2)

----------  # @Submenu@ Set Molecule Dens. By Index
# Make sure AdhesionFlex plugin is loaded
# setting adhesion molecule density using its index
# molecules are indexed in the same order they are listed in the xml file
self.adhesionFlexPlugin.setAdhesionMoleculeDensity(cell, 0, 11.2)

----------  # @Submenu@  Get Molecule Dens. By Name (Medium)
# Make sure AdhesionFlex plugin is loaded
# accessing adhesion molecule density for Medium using its name
self.adhesionFlexPlugin.getMediumAdhesionMoleculeDensity("NCad")

----------  # @Submenu@  Get Molecule Dens. By Index (Medium)
# Make sure AdhesionFlex plugin is loaded
# accessing adhesion molecule density for Medium using its index
# molecules are indexed in the same order they are listed in the xml file
self.getMediumAdhesionMoleculeDensityByIndex(0)

----------  # @Submenu@  Set Molecule Dens. By Name (Medium)
# Make sure AdhesionFlex plugin is loaded
# setting adhesion molecule density for Medium using its name
self.adhesionFlexPlugin.setMediumAdhesionMoleculeDensity("NCad", 11.2)

----------  # @Submenu@  Set Molecule Dens. By Index (Medium)
# Make sure AdhesionFlex plugin is loaded
# setting adhesion molecule density for Medium using its index
# molecules are indexed in the same order they are listed in the xml file
self.adhesionFlexPlugin.setMediumAdhesionMoleculeDensityByIndex(0, 11.2)

===============  # @Menu@ Chemotaxis

----------  # @Submenu@  By Cell Id (Define)
# Make sure Chemotaxis Plugin is loaded
# defining chemotaxis properties of individual cell 'cell'
cd = self.chemotaxisPlugin.addChemotaxisData(cell, "FIELDNAME")
cd.setLambda(20.0)
# cd.initializeChemotactTowardsVectorTypes("Bacterium,Medium")
cd.assignChemotactTowardsVectorTypes([0, 1])

----------  # @Submenu@  By Cell Id (Modify)
# Make sure Chemotaxis Plugin is loaded
# modifying chemotaxis properties of individual cell 'cell'
cd = self.chemotaxisPlugin.getChemotaxisData(cell, "FIELDNAME")
if cd:
    l = cd.getLambda() - 3
    cd.setLambda(l)

===============  # @Menu@ Inertia Tensor

----------  # @Submenu@ Information
# Make sure MomentOfInertia plugin is loaded
print("cell.iXX=", cell.iXX, " cell.iYY=", cell.iYY, " cell.iXY=", cell.iXY)
# simiilarly we can get other components of intertia tensor

----------  # @Submenu@ Semiaxes
# Make sure MomentOfInertia plugin is loaded
axes = self.momentOfInertiaPlugin.getSemiaxes(cell)
print("minorAxis=", axes[0], " majorAxis=", axes[2], " medianAxis=", axes[1])

===============  # @Menu@ Elasticity

----------  # @Submenu@ Modify Existing Links
# Make sure Elasticity plugin is loaded and Local option is on
elasticity_data_list = self.get_elasticity_data_list(cell)
for elasticity_data in elasticity_data_list:  # visiting all elastic links of 'cell'

    target_length = elasticity_data.targetLength
    elasticity_data.targetLength = 6.0
    elasticity_data.lambdaLength = 200.0
    elasticity_neighbor = elasticity_data.neighborAddress

    # now we set up elastic link data stored in neighboring cell
    neighbor_elasticity_data = None
    neighbor_elasticity_data_list = self.get_elasticity_data_list(elasticity_neighbor)
    for neighbor_elasticity_data_tmp in neighbor_elasticity_data_list:
        if not self.are_cells_different(neighbor_elasticity_data_tmp.neighborAddress, cell):
            neighbor_elasticity_data = neighbor_elasticity_data_tmp
            break

    if neighbor_elasticity_data is None:
        print ("None Type returned."
               " Problems with ElasticityDataNeighbors initialization or sets of elasticityNeighborData are corrupted")
        sys.exit()
    neighbor_elasticity_data.targetLength = 6.0
    neighbor_elasticity_data.lambdaLength = 200.0

----------  # @Submenu@ Add New Elastic Link
# Make sure Elasticity plugin is loaded and Local option is on
# arguments are cell1, cell2, lambdaElasticLink,targetLinkLength
self.elasticityTrackerPlugin.addNewElasticLink(cell1, cell2, 200.0, 6.0)

----------  # @Submenu@ Remove Elastic Link
# Make sure Elasticity plugin is loaded and Local option is on
# arguments are cell1, cell2,
self.elasticityTrackerPlugin.removeElasticityPair(cell1, cell2, 200.0, 6.0)

===============  # @Menu@ Secretion / Uptake

----------  # @Submenu@ Secrete Inside Cell
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteInsideCell(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteInsideCellAtBoundary(cell, 300)

----------  # @Submenu@ Secrete Outside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteOutsideCellAtBoundary(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At COM
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteInsideCellAtCOM(cell, 300)

----------  # @Submenu@ Secrete Inside Cell Constant Concentration
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteInsideCellConstantConcentration(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At Boundary On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, secretion rate, a list of cell types
secretor.secreteInsideCellConstantConcentration(cell, 300, [self.TYPE1, self.TYPE2])

----------  # @Submenu@ Secrete Outside Cell At Boundary On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, secretion rate, a list of cell types
secretor.secreteOutsideCellConstantConcentration(cell, 300, [self.TYPE1, self.TYPE2])

----------  # @Submenu@ Uptake Inside Cell
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake
secretor.uptakeInsideCell(cell, 2.0, 0.2)

----------  # @Submenu@ Uptake Inside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake
secretor.uptakeInsideCellAtBoundary(cell, 2.0, 0.2)

----------  # @Submenu@ Uptake Outside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake
secretor.uptakeInsideCellAtBoundary(cell, 2.0, 0.2)

----------  # @Submenu@ Uptake Inside Cell At COM
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake
secretor.uptakeInsideCellAtCOM(cell, 2.0, 0.2)

----------  # @Submenu@ Uptake Inside Cell At Boundary and On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake, a list of cell types
secretor.uptakeInsideCellAtBoundaryOnContactWith(cell, 2.0, 0.2, [self.TYPE1, TYPE2])

----------  # @Submenu@ Uptake Outside Cell At Boundary and On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake, a list of cell types
secretor.uptakeOutsideCellAtBoundaryOnContactWith(cell, 2.0, 0.2, [self.TYPE1, TYPE2])

===============  # @Menu@ Extra Fields Automatic Tracking

----------  # @Submenu@  Track Scalar Cell Attribute (__init__)
self.track_cell_level_scalar_attribute(field_name='FIELD_NAME', attribute_name='ATTR_NAME')

----------  # @Submenu@  Track Scalar Cell Attribute Custom Function (__init__)
self.track_cell_level_scalar_attribute(field_name='FIELD_NAME', attribute_name='ATTR_NAME',
                                       function=lambda attr_val: attr_val ** 3)

----------  # @Submenu@  Track Vector Cell Attribute (__init__)
self.track_cell_level_vector_attribute(field_name='mcs_vec', attribute_name='mcs_vec')

----------  # @Submenu@  Track Vector Cell Attribute Custom Function (__init__)
self.track_cell_level_vector_attribute(field_name='FIELD_NAME', attribute_name='VEC_NAME',
                                       function=lambda vec: [vec[0] * random(), vec[1] * random(), vec[2] * random()])

===============  # @Menu@ Extra Fields

----------  # @Submenu@  Scalar Field Cell Level - Example
from random import random
field = self.field.SCALAR_CL_FIELD

# clear field
field.clear()

for cell in self.cell_list:
    field[cell] = cell, cell.id * random()

----------  # @Submenu@ Scalar Field Cell Level - Create (__init__ fcn.)
self.create_scalar_field_cell_level_py("FIELD_NAME_SCL")

----------  # @Submenu@ Scalar Field Cell Level - Clear (step fcn.)
field = self.field.SCALAR_CL_FIELD.clear()

----------  # @Submenu@ Scalar Field Cell Level - Write (step fcn.)
field = self.field.SCALAR_CL_FIELD
field[cell] = FLOAT_VALUE

----------  # @Submenu@ Scalar Field Pixel Level - Example
import math
field = self.field.SCALAR_FIELD

# clear field
field[:, :, :] = 0.0

for x, y, z in self.every_pixel():
    if not mcs % 20:
        field[x, y, z] = x * y

    else:
        field[x, y, z] = math.sin(x * y)

----------  # @Submenu@ Scalar Field Pixel Level - Create (__init__ fcn.)
self.create_scalar_field_py("FIELD_NAME_S")

----------  # @Submenu@ Scalar Field Pixel Level - Clear (step fcn.)
field = self.field.SCALAR_FIELD
field[:, :, :] = 0.0

----------  # @Submenu@ Scalar Field Pixel Level - Write (step fcn.)
field = self.field.SCALAR_FIELD
field[10, 11, 0] = FLOAT_VALUE

----------  # @Submenu@ Vector Field Cell Level - Example
from random import random
field = self.field.VECTOR_CL_FIELD

field.clear()
for cell in self.cell_list:
    if cell.type == 1:
        field[cell] = [cell.id * random(), cell.id * random(), 0]
        vec = field[cell]
        vec *= 2.0
        field[cell] = vec

----------  # @Submenu@ Vector Field Cell Level - Create (__init__ fcn.)
self.create_vector_field_cell_level_py("FIELD_NAME_VCL")

----------  # @Submenu@ Vector Field Cell Level - Clear (step fcn.)
field = self.field.VECTOR_CL_FIELD.clear()

----------  # @Submenu@ Vector Field Cell Level - Write (step fcn.)
field = self.field.VECTOR_CL_FIELD
field[cell] = [VEC_X, VEC_Y, VEC_Z]

----------  # @Submenu@ Vector Field Pixel Level - Example
field = self.field.VECTOR_FIELD
# clear vector field
field[:, :, :, :] = 0.0

for x in range(0, self.dim.x, 5):
    for y in range(0, self.dim.y, 5):
        for z in range(self.dim.z):
            field[x, y, z] = [x * random(), y * random(), z * random()]

----------  # @Submenu@ Vector Field Pixel Level - Create (__init__ fcn.)
self.create_vector_field_py("FIELD_NAME_V")

----------  # @Submenu@ Vector Field Pixel Level - Clear (step fcn.)
field = self.field.VECTOR_FIELD
# clear vector field
field[:, :, :, :] = 0.0

----------  # @Submenu@ Vector Field Pixel Level - Write (step fcn.)
field = self.field.VECTOR_FIELD
field[x, y, z] = [VEC_X, VEC_Y, VEC_Z]

===============  # @Menu@ Scientific Plots

----------  # @Submenu@ 1. Setup (start fcn)

self.plot_win = self.add_new_plot_window(title='Average Volume And Surface',
                                         x_axis_title='MonteCarlo Step (MCS)',
                                         y_axis_title='Variables', x_scale_type='linear', y_scale_type='linear',
                                         grid=False)

self.plot_win.add_plot("MVol", style='Lines', color='red', size=5)
self.plot_win.add_plot("MSur", style='Dots', color='green', size=1)


----------  # @Submenu@ 2. Add Data Points (step fcn)
# arguments are (name of the data series, x, y)
self.plot_win.add_data_point("MVol", mcs, mcs**2)
self.plot_win.add_data_point("MSur", mcs, mcs)


----------  # @Submenu@ Erase Plot (step fcn)
self.plot_win.erase_all_data()

----------  # @Submenu@ 3. Refresh Plots (unnecessary, deprecated - step fcn )
self.plot_win.show_all_plots()

----------  # @Submenu@ Save Plot As A PNG File
# here we specify size of the image saved (1000x1000) - default is 400 x 400
# resizing of the image is not guaranteed to be implemented
self.plot_win.save_plot_as_png(file_name, 1000, 1000)

----------  # @Submenu@ Save Plot As Data (text file)
self.plot_win.save_plot_as_data(file_name)

===============  # @Menu@ Scientific Plots Histograms

----------  # @Submenu@ 1. Add Histogram Plot (start fcn)
# initialize setting for Histogram
self.plot_win = self.add_new_plot_window(title='Histogram of Cell Volumes', x_axis_title='Number of Cells',
                                         y_axis_title='Volume Size in Pixels')
# _alpha is transparency 0 is transparent, 255 is opaque
self.plot_win.add_histogram_plot(plot_name='Hist 1', color='green', alpha=100)
self.plot_win.add_histogram_plot(plot_name='Hist 2', color='red', alpha=100)
self.plot_win.add_histogram_plot(plot_name='Hist 3', color='blue')

----------  # @Submenu@ 2. Add Histogram  (step fcn)
self.plot_win.add_histogram(plot_name='Hist 1', value_array=gauss, number_of_bins=10)
self.plot_win.add_histogram(plot_name='Hist 2', value_array=vol_list, number_of_bins=10)
self.plot_win.add_histogram(plot_name='Hist 3', value_array=vol_list, number_of_bins=50)


----------  # @Submenu@ Save  Plot As A PNG File
# here we specify size of the image saved (1000x1000) - default is 400 x 400
# resizing of the image is not guaranteed to be implemented
self.plot_win.save_plot_as_png(file_name, 1000, 1000)

----------  # @Submenu@ Save Plot As Data (text file)
self.plot_win.save_plot_as_data(file_name)

===============  # @Menu@ Simulation

----------  # @Submenu@ Stop Simulation
self.stop_simulation()

----------  # @Submenu@ Set Max MCS
self.set_max_mcs(MAX_MCS)

----------  # @Submenu@ Change Steppable Frequency
self.frequency = NEW_FREQUENCY

----------  # @Submenu@ Build Wall
self.build_wall(self.YOUR_WALL_CELL_TYPE)

----------  # @Submenu@ Destroy Wall
self.destroy_wall()

----------  # @Submenu@ Resize And Shift Lattice
self.resize_and_shift_lattice(new_size=(X, Y, Z), shift_vec=(VX, VY, VZ))

----------  # @Submenu@ Change Number of CPU's (worknodes)
self.change_number_of_work_nodes(8)

===============  # @Menu@ Mitosis

----------  # @Submenu@ 1. Clone Attributes Parent -> Child
self.clone_parent_2_child()

----------  # @Submenu@ 1. Clone Cluster Attributes Parent -> Child
self.clone_parent_cluster_2_child_cluster()

----------  # @Submenu@ 2. Compact updateAttributes
self.parent_cell.targetVolume /= 2.0  # reducing parent target volume
self.clone_parent_2_child()

----------  # @Submenu@ 2. Compact updateAttributes for clusters
# we first redice target volum of the cluster of parent cell
compartment_list_parent = self.get_cluster_cells(self.parent_cell.clusterId)
for i in range(compartment_list_parent.size()):
    compartment_list_parent[i].targetVolume /= 2.0

# later we clone attributes from parent cluster to child cluster
self.clone_parent_cluster_2_child_cluster()

----------  # @Submenu@ Clone Attributes (Flexible)
self.clone_attributes(source_cell=self.parent_cell, target_cell=self.child_cell, no_clone_key_dict_list=[ATTRIB_1, ATTRIB_2])

----------  # @Submenu@ Child/Parent Random Relative Position
self.set_parent_child_position_flag(0)

----------  # @Submenu@ Child on the Left of the Parent
self.set_parent_child_position_flag(1)

----------  # @Submenu@ Child on the Right of the Parent
self.set_parent_child_position_flag(-1)

----------  # @Submenu@ Divide Cells Along Random Axis (Example)
cells_to_divide = []
for cell in self.cell_list:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divide_cell_random_orientation(cell)

----------  # @Submenu@ Divide Cells Along Major Axis (Example)
cells_to_divide = []
for cell in self.cell_list:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divide_cell_along_major_axis(cell)

----------  # @Submenu@ Divide Cells Along Minor Axis (Example)
cells_to_divide = []
for cell in self.cell_list:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divide_cell_along_minor_axis(cell)

----------  # @Submenu@ Divide Cells Along Normal To Vector (Example)
cells_to_divide = []
for cell in self.cell_list:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    # dividing along Y axis - normal to (1,0,0)
    self.divide_cell_orientation_vector_based(cell, 1, 0, 0)

----------  # @Submenu@ Divide Cluster Along Random Axis (Example)
mitosis_cluster_id_list = []
for compartment_list in self.cluster_list:

    cluster_id = 0
    cluster_volume = 0
    for cell in CompartmentList(compartment_list):
        cluster_volume += cell.volume
        cluster_id = cell.clusterId

    # condition under which cluster mitosis takes place
    if cluster_volume > 250:
        # instead of doing mitosis right away we store ids for clusters which should be divide.
        # This avoids modifying cluster list while we iterate through it
        mitosis_cluster_id_list.append(cluster_id)

for cluster_id in mitosis_cluster_id_list:
    self.divide_cluster_random_orientation(cluster_id)

----------  # @Submenu@ Divide Cluster Along Major Axis (Example)
mitosis_cluster_id_list = []
for compartment_list in self.cluster_list:

    cluster_id = 0
    cluster_volume = 0
    for cell in CompartmentList(compartment_list):
        cluster_volume += cell.volume
        cluster_id = cell.clusterId

    # condition under which cluster mitosis takes place
    if cluster_volume > 250:
        # instead of doing mitosis right away we store ids for clusters which should be divide.
        # This avoids modifying cluster list while we iterate through it
        mitosis_cluster_id_list.append(cluster_id)

for cluster_id in mitosis_cluster_id_list:
    self.divide_cluster_along_major_axis(cluster_id)

----------  # @Submenu@ Divide Cluster Along Minor Axis (Example)
mitosis_cluster_id_list = []
for compartment_list in self.clusterList:

    cluster_id = 0
    cluster_volume = 0
    for cell in CompartmentList(compartment_list):
        cluster_volume += cell.volume
        cluster_id = cell.clusterId

    # condition under which cluster mitosis takes place
    if cluster_volume > 250:
        # instead of doing mitosis right away we store ids for clusters which should be divide.
        # This avoids modifying cluster list while we iterate through it
        mitosis_cluster_id_list.append(cluster_id)

for cluster_id in mitosis_cluster_id_list:
    self.divide_cluster_along_major_axis(cluster_id)

----------  # @Submenu@ Divide Cluster Along Normal To Vector (Example)
mitosis_cluster_id_list = []
for compartment_list in self.clusterList:

    cluster_id = 0
    cluster_volume = 0
    for cell in CompartmentList(compartment_list):
        cluster_volume += cell.volume
        cluster_id = cell.clusterId

    # condition under which cluster mitosis takes place
    if cluster_volume > 250:
        # instead of doing mitosis right away we store ids for clusters which should be divide.
        # This avoids modifying cluster list while we iterate through it
        mitosis_cluster_id_list.append(cluster_id)

for cluster_id in mitosis_cluster_id_list:
    self.divideClusterOrientationVectorBased(cluster_id, 1, 0, 0)

===============  # @Menu@ Parameter Scan Command Line

----------  # @Submenu@ 1. Run Parameter Scan Using Player (Windows)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.bat - i < cc3dproject - file > --guiScan --maxNumberOfRuns=20[remaining command
line
options
used in compucell3d.bat or runScript.bat]

----------  # @Submenu@ 1. Run Parameter Scan With No GUI (Windows)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.bat - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.bat or runScript.bat]

----------  # @Submenu@ 2. Run Parameter Scan Using Player (Linux)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.sh - i < cc3d
project - file > --guiScan - -maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.sh or runScript.sh]

----------  # @Submenu@ 2. Run Parameter Scan With No GUI (Linux)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.sh - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.sh or runScript.sh]

----------  # @Submenu@ 3. Run Parameter Scan Using Player (OSX)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.command - i < cc3d
project - file > --guiScan - -maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.command or runScript.command]

----------  # @Submenu@ 3. Run Parameter Scan With No GUI (OSX)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.command - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.command or runScript.command]
