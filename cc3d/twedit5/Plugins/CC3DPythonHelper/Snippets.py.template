===============  # @Menu@ Python Utilities

----------  # @Submenu@ Open File In Simulation Output Directory
file_obj, file_path = self.open_file_in_simulation_output_folder("<FILE_NAME>", mode='w')
if file_obj is None:
    return

----------  # @Submenu@ Open File In Parameter Scan Main  Output Directory
file_obj, file_path = self.open_file_in_parameter_scan_main_output_folder("<FILE_NAME>", mode='w')
if file_obj is None:
    return

----------  # @Submenu@ Open File In Simulation Output Directory (low-level)
from pathlib import Path

if self.output_dir is not None:
    output_path = Path(self.output_dir).joinpath("<FILE_NAME>")
    # create folder to store data
    output_path.parent.mkdir(parents=True, exist_ok=True)
    try:
        file_handle = open(output_path, 'w')
    except IOError:
        print ("Could not open file for writing.")
        return

----------  # @Submenu@ Fetch Steppable By Class Name
self.getSteppableByClassName('STEPPABLE_CLASS_NAME')

----------  # @Submenu@ Get Dir Of Current File
fileDir = os.path.dirname(os.path.abspath(__file__))

----------  # @Submenu@ Get FullPath Of Current File
filePath = os.path.abspath(__file__)

----------  # @Submenu@ Import os
import os

----------  # @Submenu@ Set Simulation Output Directory (main Python script)
# It is best to call this function from __init__ of first registered steppable
self.set_output_dir(output_dir="<CUSTOM_OUTPUT_DIR>", abs_path=False)

===============  # @Menu@ SBML Solver

----------  # @Submenu@ 1. Model Initial Data
# this can be e.g. partial path 'Simulation/osci.sbml'
model_file = 'PATH_TO_SBML_MODEL'

initial_conditions = {}
initial_conditions['SPECIES_NAME1'] = species_val1
initial_conditions['SPECIES_NAME2'] = species_val2

step_size = 0.5

----------  # @Submenu@ 2. Add SBML model to cell ids
self.add_sbml_to_cell_ids(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell_ids=[1, 3, 7], step_size=step_size,
                          initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add Antimony model to cell ids
# input Antimony model in file 'model_file' or string 'model_string'
# If using model_string, enclose entire model in a set of triple quotations
# Initial conditions can be declared in model or with initial_conditions; the latter takes precedence
# Model is translated to SBML and stored in memory; use SBML functions in subsequent operations
self.add_antimony_to_cell_ids(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell_ids=[1, 3, 7], step_size=step_size,
                          initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add CellML model to cell ids
# input CellML model in file 'model_file' or string 'model_string'
# If using model_string, enclose entire model in a set of triple quotations
# Initial conditions can be declared in model or with initial_conditions; the latter takes precedence
# Model is translated to SBML and stored in memory; use SBML functions in subsequent operations
self.add_cellml_to_cell_ids(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell_ids=[1, 3, 7], step_size=step_size,
                          initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add SBML model to cell types
self.add_sbml_to_cell_types(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell_types=[self.CELLTYPENAME1, self.CELLTYPENAME1],
                        step_size=step_size, initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add Antimony model to cell types
# input Antimony model in file 'model_file' or string 'model_string'
# If using model_string, enclose entire model in a set of triple quotations
# Initial conditions can be declared in model or with initial_conditions; the latter takes precedence
# Model is translated to SBML and stored in memory; use SBML functions in subsequent operations
self.add_antimony_to_cell_types(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell_types=[self.CELLTYPENAME1, self.CELLTYPENAME1],
                        step_size=step_size, initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add CellML model to cell types
# input CellML model in file 'model_file' or string 'model_string'
# If using model_string, enclose entire model in a set of triple quotations
# Initial conditions can be declared in model or with initial_conditions; the latter takes precedence
# Model is translated to SBML and stored in memory; use SBML functions in subsequent operations
self.add_cellml_to_cell_types(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell_types=[self.CELLTYPENAME1, self.CELLTYPENAME1],
                        step_size=step_size, initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add SBML model to individual cell
cell_20 = self.fetch_cell_by_id(20)

if cell_20:
    self.add_sbml_to_cell(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell=cell_20,step_size=step_size,
                          initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add Antimony model to individual cell
# input Antimony model in file 'model_file' or string 'model_string'
# If using model_string, enclose entire model in a set of triple quotations
# Initial conditions can be declared in model or with initial_conditions; the latter takes precedence
# Model is translated to SBML and stored in memory; use SBML functions in subsequent operations
cell_20 = self.fetch_cell_by_id(20)

if cell_20:
    self.add_antimony_to_cell(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell=cell_20,step_size=step_size,
                          initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add CellML model to individual cell
# input CellML model in file 'model_file' or string 'model_string'
# If using model_string, enclose entire model in a set of triple quotations
# Initial conditions can be declared in model or with initial_conditions; the latter takes precedence
# Model is translated to SBML and stored in memory; use SBML functions in subsequent operations
cell_20 = self.fetch_cell_by_id(20)

if cell_20:
    self.add_cellml_to_cell(model_file=model_file, model_string=model_string, model_name='MODEL_NAME', cell=cell_20,step_size=step_size,
                          initial_conditions=initial_conditions)


----------  # @Submenu@ 2. Add free floating SBML model e.g. PBPK
# input Antimony model in file 'model_file' or string 'model_string'
# If using model_string, enclose entire model in a set of triple quotations
# Initial conditions can be declared in model or with initial_conditions; the latter takes precedence
# Model is translated to SBML and stored in memory; use SBML functions in subsequent operations
self.add_free_floating_sbml(model_file=model_file, model_string=model_string, model_name='UNIQUE_MODEL_NAME', step_size=step_size,
                            initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add free floating Antimony model
# input CellML model in file 'model_file' or string 'model_string'
# If using model_string, enclose entire model in a set of triple quotations
# Initial conditions can be declared in model or with initial_conditions; the latter takes precedence
# Model is translated to SBML and stored in memory; use SBML functions in subsequent operations
self.add_free_floating_antimony(model_file=model_file, model_string=model_string, model_name='UNIQUE_MODEL_NAME', step_size=step_size,
                            initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add free floating CellML model
self.add_free_floating_cellml(model_file=model_file, model_string=model_string, model_name='UNIQUE_MODEL_NAME', step_size=step_size,
                            initial_conditions=initial_conditions)

----------  # @Submenu@ 3. Timestep SBML models
self.timestep_sbml()

----------  # @Submenu@ 5. Copy select SBMLs
self.copy_sbml_simulators(from_cell=source_cell, to_cell=target_cell, sbml_names=['MODEL_NAME1', 'MODEL_NAME2'])

----------  # @Submenu@ 5. Copy All SBMLs
self.copy_sbml_simulators(from_cell=source_cell, to_cell=target_cell)

----------  # @Submenu@  Get SBML State for individual cell
# returns dictionary of values
state = cell.sbml.MODELNAME


----------  # @Submenu@  Get SBML State for Free Floating model
state = self.sbml.UNIQUE_MODEL_NAME

----------  # @Submenu@  Get SBML Value for SBML in a specific cell
# value name can be e.g. species name
# example cell.DN.Delta
cell.sbml.MODEL_NAME['VALUE_NAME']

----------  # @Submenu@  Get SBML Value for Free Floating model
# value name can be e.g. species name
self.sbml.MODEL_NAME['VALUE_NAME']

----------  # @Submenu@  Get SBML Simulator for individual cell (advanced)
# example cell.sbml._rr_DN
cell.sbml._rr_MODEL_NAME

----------  # @Submenu@  Get SBML Simulator for Free Floating Model (advanced)
# example self.sbml._rr_DN
self.sbml._rr_MODEL_NAME

----------  # @Submenu@  Set SBML State for individual cell
state = {}
state['REACTANT_NAME'] = 0.9

self.set_sbml_state(model_name='MODELNAME', cell=cell, state=state)

----------  # @Submenu@  Set SBML State for Free Floating model
state = {}
state['REACTANT_NAME'] = 0.9
self.set_sbml_state(model_name='MODELNAME',  state=state)

----------  # @Submenu@  Set SBML Value for SBML in a specific cell
# value name can be e.g. species name
cell.sbml.UNIQUE_MODEL_NAME['VALUE_NAME'] = 0.1

----------  # @Submenu@  Set SBML Value for Free Floating model
# value name can be e.g. species name
self.sbml.UNIQUE_MODEL_NAME['VALUE_NAME'] = 0.1

----------  # @Submenu@  Delete SBML from cell ids
self.delete_sbml_from_cell_ids(model_name='MODEL_NAME', cell_ids=[1, 4, 7])

----------  # @Submenu@  Delete SBML from cell types
self.delete_sbml_from_cell_types(model_name='MODEL_NAME', cell_types=[self.CELLTYPE1, self.CELLTYPE2])

----------  # @Submenu@  Delete SBML from individual cell
self.delete_sbml_from_cell(model_name='MODEL_NAME', cell=cell)

----------  # @Submenu@  Delete Free Floating SBML
self.delete_free_floating_sbml(model_name='UNIQUE_MODEL_NAME')

----------  # @Submenu@  Set SBML Integrator Global Options
# adding options that setup SBML solver integrator - these are optional but useful when encountering
# integration instabilities
# relative is relative tolerance, absolute is absolute tolerance,
# steps is the initial number of integration steps for each integration interval
# (higher number does not result in slower simulation, quite to the contrary),
# stiff set to true will use stiff ODE solver
options = {'relative': 1e-10, 'absolute': 1e-12, 'steps': 10, 'stiff': False}
self.set_sbml_global_options(options)

----------  # @Submenu@  Get SBML Integrator  Global Options
# returns current options - can be None if no global options were set
options = self.get_sbml_global_options()

===============  # @Menu@ Steering Panel

----------i1  # @Submenu@ 1.Set Up Steering Panel


def add_steering_panel(self):
    self.add_steering_param(name='MY_PARAM_SLIDER', val=20, min_val=0, max_val=100,
                            decimal_precision=2, widget_name='slider')
    self.add_steering_param(name='MY_PARAM_COMBO', val=20, enum=[10,20,30,40,50,60,70,80,90,100],
                                widget_name='combobox')

def process_steering_panel_data(self):
    print ('processing steering panel updates')
    print ('all dirty flag=', self.steering_param_dirty())
    param_slider = self.get_steering_param('MY_PARAM_SLIDER')
    param_combo = self.get_steering_param('MY_PARAM_COMBO')
    print ('updated MY_PARAM_SLIDER=',param_slider)
    print ('updated MY_PARAM_COMBO=', param_combo)

    # IMPORTANT: you may add code here tht updates cell properties based on the
    # values of the parameters from the steering panel. For example:

    # for cell in self.cellList:
    #     cell.targetVolume = param_slider
    #     cell.lambdaVolume = param_combo

----------  # @Submenu@ Get Updated Value of Steering Parameter
my_param = self.get_steering_param('MY_PARAM')

----------  # @Submenu@ Check if Steering Panel Was Updated
updated_flag = self.steering_param_dirty()

===============  # @Menu@ Cell Constraints

----------  # @Submenu@ Change Target Volume
cell.targetVolume = 25

----------  # @Submenu@ Change Lambda Volume
cell.lambdaVolume = 2.0

----------  # @Submenu@ Change Target Surface
cell.targetSurface = 20.0

----------  # @Submenu@ Change Lambda Surface
cell.lambdaSurface = 2.0

----------  # @Submenu@ Change Lambda Motility
cell.lambdaMotility = 15.0

----------  # @Submenu@ Apply Force To Cell
# Make sure ExternalPotential plugin is loaded
cell.lambdaVecX = -0.5  # force component pointing along X axis - towards positive X's
cell.lambdaVecY = 0.5  # force component pointing along Y axis - towards negative Y's
cell.lambdaVecZ = 0.0  # force component pointing along Z axis

----------  # @Submenu@ Length Constraint By Cell Id
# Make sure LengthConstraintLocalFlex plugin is loaded
# Argument Order: cell , lambdaLength, targetLength
self.lengthConstraintLocalFlexPlugin.setLengthConstraintData(cell, 20, 20)

----------  # @Submenu@ Connectivity Constraint By Cell Id
# Make sure ConnectivityLocalFlex plugin is loaded
# Argument Order: cell, strength
self.connectivityLocalFlexPlugin.setConnectivityStrength(cell, 10000000)

===============  # @Menu@ Cell Manipulation

----------  # @Submenu@ Fetch Cell By Id
cell = self.fetch_cell_by_id(CELL_ID)

----------  # @Submenu@ Delete Cell
self.delete_cell(cell)

----------  # @Submenu@ Create Cell
# size of cell will be 3x3x1
self.cell_field[10:12, 10:12, 0] = self.new_cell(self.TYPENAME)

----------  # @Submenu@ Create Cell (detailed)
x = X_POSITION
y = Y_POSITION
size = SIZE
cell = self.new_cell(self.TYPENAME)
# size of cell will be SIZExSIZEx1
self.cell_field[x:x + size - 1, y:y + size - 1, 0] = cell

----------  # @Submenu@ Get Cell At a Pixel
cell = self.cell_field[10, 11, 0]

----------  # @Submenu@ Move Cell
# Shifting entire cell by a 'shiftVector'
# Requires PixelTracker Plugin         
shift_vector = [20, 20, 0]
self.move_cell(cell, shift_vector)

----------  # @Submenu@ Merge Cell
# Turns all voxels of SOURCE_CELL into voxels of DESTINATION_CELL
# This function will merge the cells regardless of the distance between them.
# It won't update the DESTINATION_CELL target volume.
# Use with care.
self.merge_cells(SOURCE_CELL, DESTINATION_CELL)

===============  # @Menu@ Distances, Vectors, Transformations

----------  # @Submenu@ Distance Vector Between Cells
vec = self.distance_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance Vector Between Cells (Invariant)
vec = self.invariant_distance_vector_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance  Between Cells
vec = self.distance_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance  Between Cells (Invariant)
vec = self.invariant_distance_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance Vector Between Points
vec = self.distance(p1=[10, 10, 0], p2=[11, 11, 0])

----------  # @Submenu@ Distance Vector Between Points (Invariant)
vec = self.unconditional_invariant_distance_vector(p1=[10, 10, 0], p2=[11, 11, 0])

----------  # @Submenu@ Distance Vector Between Points (Invariant, Integer)
vec = self.invariant_distance_vector_integer(p1=[10, 10, 0], p2=[11, 11, 0])

----------  # @Submenu@ Vector Norm
norm = self.vector_norm(VECTOR)

----------  # @Submenu@ Hex: Hex 2 Cartesian
# returns Point3D
pt = self.hex_2_cartesian(coords=COORDS)

----------  # @Submenu@ Hex: Cartesian 2 Hex
# retutns Coordinates<double>
coords = self.cartesian_2_hex(coords=POINT3D)

----------  # @Submenu@ Numpy: Point3D To Numpy Array
ptArray = self.point_3d_to_numpy(PT)

----------  # @Submenu@ Numpy: Numpy Array To Point3D
pt = self.numpy_to_point_3d(PT_ARRAY)

----------  # @Submenu@ Hex: Cartesian 2 Hex
coords = self.cartesian_2_hex(coords=POINT3D)  # retutns Coordinates<double>

===============  # @Menu@ Visit

----------  # @Submenu@ All Cells
# iterating over all cells in simulation        
for cell in self.cell_list:
    # you can access/manipulate cell properties here
    print("id=", cell.id, " type=", cell.type, " volume=", cell.volume)

----------  # @Submenu@ All Cells Of Given Type
# iterating over cells of type 1
# list of  cell types (capitalized)
for cell in self.cell_list_by_type(self.TYPENAME_1, self.TYPENAME_2, ...):
    # you can access/manipulate cell properties here
    print ("id=", cell.id, " type=", cell.type)

----------  # @Submenu@ Cell Neighbors
for neighbor, common_surface_area in self.get_cell_neighbor_data_list(cell):
    if neighbor:
        print("neighbor.id", neighbor.id, " commonSurfaceArea=", common_surface_area)
    else:
        print("Medium commonSurfaceArea=", common_surface_area)

----------  # @Submenu@ Cells In Cluster (compartments)
fo cell in self.cell_list:
    cluster_cell_list = self.get_cluster_cells(cell.clusterId)
    for cell_cmpt in cluster_cell_list:
        print('compartmental cell id=', cell_cmpt)

----------  # @Submenu@ Cell Boundary Pixels
# Make sure BoundaryPixelTracker plugin is loaded
pixel_list = self.get_cell_boundary_pixel_list(cell)
for boundary_pixel_tracker_data in pixel_list:
    print("pixel of cell id=", cell.id, " type:", cell.type, " = ",
          boundary_pixel_tracker_data.pixel, " number of pixels=", pixel_list.numberOfPixels())

----------  # @Submenu@ Cell Pixels
# Make sure PixelTracker plugin is loaded
pixel_list = self.get_cell_pixel_list(cell)
for pixel_tracker_data in pixel_list:
    print("pixel of cell id=", cell.id, " type:", cell.type, " = ", pixel_tracker_data.pixel,
          " number of pixels=", pixel_list.numberOfPixels())

----------  # @Submenu@ All Lattice Pixels
for x, y, z in self.every_pixel():
    print("x,y,z=", (x, y, z))

----------  # @Submenu@ All Clusters
for compartments in self.clusters:
    print('compartments=', compartments)

----------  # @Submenu@ All Clusters and Cells Withing Clusters
for compartments in self.clusters:
    for cell in compartments:
        print(cell.id)

===============  # @Menu@ Chemical Field Manipulation

----------  # @Submenu@ Get Field Reference
field = self.field.FIELD_NAME

----------  # @Submenu@ Get Field Min Value
minValue = field.min()

----------  # @Submenu@ Get Field Max Value
maxValue = field.max()

----------  # @Submenu@ Get Field Value
value = field[10, 10, 0]

----------  # @Submenu@ Set Field Value
field[10, 10, 0] = 1.02

----------  # @Submenu@ Write To Disk

field = self.field.FIELD_NAME
output_dir = self.output_dir


if output_dir is not None:
    output_path = Path(output_dir).joinpath(FILE_NAME)
    # create folder to store data
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'w') as file_handle:
        for i, j, k in self.every_pixel():
            file_handle.write("%d\t%d\t%d\t%f\n" % (i, j, k, field[i, j, k]))

----------  # @Submenu@ Modification (aka secretion)
field = self.field.FIELD_NAME
if field:
    for i, j, k in self.every_pixel():
        field[i, j, k] = i * j

===============  # @Menu@ Cell Attributes

----------  # @Submenu@ Check If Two Cells Are Different
self.are_cells_different(cell1, cell2)

----------  # @Submenu@ Access/Modify Dictionary Attribute
# access/modification of a dictionary attached to cell - make sure to declare in main script that
# you will use such attribute
cell.dict['ATTR_NAME'] = VALUE_OR_OBJECT

----------  # @Submenu@ Center Of Mass
# Make sure CenterOfMass plugin is loaded
# READ ONLY ACCESS
xCOM = cell.xCOM
yCOM = cell.yCOM
zCOM = cell.zCOM

----------  # @Submenu@ Volume
# READ ONLY ACCESS        
volume = cell.volume

----------  # @Submenu@ Target Volume
# READ/WRITE  ACCESS                
target_volume = cell.targetVolume

----------  # @Submenu@ Lambda Volume
# READ/WRITE  ACCESS        
lambda_volume = cell.lambdaVolume

----------  # @Submenu@ Surface
# READ ONLY ACCESS        
surface = cell.surface

----------  # @Submenu@ Target Surface
# READ/WRITE  ACCESS                
target_surface = cell.targetSurface

----------  # @Submenu@ Lambda Surface
# READ/WRITE  ACCESS        
lambda_surface = cell.lambdaSurface

----------  # @Submenu@ Id
# READ ONLY ACCESS        
id = cell.id

----------  # @Submenu@ Cluster Id
# READ ONLY ACCESS - can be modified using reassignClusterId function        
cluster_id = cell.clusterId

----------  # @Submenu@ Cluster Id Reassignment
# You cannot simply set cluster Id on a cell to make t belong to other cluster you
# have to use the following function call
# changing cluster id to 1536 for cell 'cell'
self.reassign_cluster_id(cell, 1536)

----------  # @Submenu@ Cell Type
# READ/WRITE  ACCESS                
cell_type = cell.type

----------  # @Submenu@ Fluctuation Ampl
# READ/WRITE  ACCESS                        
fluct_ampl = cell.fluctAmpl

----------  # @Submenu@ Fluctuation Ampl Reassignment
cell.fluctAmpl = 50
# uncomment line below to use globally defined FluctuationAmplitude
# cell.fluctAmpl=-1

----------  # @Submenu@ Inertia Tensor
# READ ONLY ACCESS        
iXX = cell.iXX
iYY = cell.iYY
iZZ = cell.iZZ
iXY = cell.iXY
iXZ = cell.iXZ
iYZ = cell.iYZ
eccentricity = cell.ecc

===============  # @Menu@ Focal Point Placticity

----------  # @Submenu@ Link property: lambda
# ld = link.getLambdaDistance()
# link.setLambdaDistance(1.0)

----------  # @Submenu@ Link property: target distance
# td = link.getTargetDistance()
# link.setTargetDistance(1.0)

----------  # @Submenu@ Link property: maximum distance
# md = link.getMaxDistance()
# link.setMaxDistance(1.0)

----------  # @Submenu@ Link property: maximum number of junctions
# mnj = link.getMaxNumberOfJunctions()
# link.setMaxNumberOfJunctions(1)

----------  # @Submenu@ Link property: activation energy
# ae = link.getActivationEnergy()
# link.setActivationEnergy(1.0)

----------  # @Submenu@ Link property: neighbor order
# no = link.getNeighborOrder()
# link.setNeighborOrder(1)

----------  # @Submenu@ Link property: initialization step
# im = link.getInitMCS()

----------  # @Submenu@ Link property: linked cell(s)
# For regular and internal links, two cells are linked:
# initiator_cell, initiated_cell = link.cellPair
# For anchors, only one cell is linked:
# linked_cell = link.cell

----------  # @Submenu@ Link property: anchor point (anchor only)
ap = link.getAnchorPoint()
link.setAnchorPoint([0.0, 1.0, 2.0])

----------  # @Submenu@ Link property: anchor id (anchor only)
aid = link.getAnchorId()

----------  # @Submenu@ Link management: Create FPP Link
# Make sure FocalPointPlacticity plugin is loaded
# Arguments are:
# initiator: CellG, initiated: CellG, lambda_distance: float, target_distance: float, max_distance: float
link = self.new_fpp_link(initiator, initiated, lambda_distance, target_distance, max_distance)

----------  # @Submenu@ Link management: Create FPP Internal Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
# Arguments are:
# initiator: CellG, initiated: CellG, lambda_distance: float, target_distance: float, max_distance: float
link = self.new_fpp_internal_link(initiator, initiated, lambda_distance, target_distance, max_distance)

----------  # @Submenu@ Link management: Create Anchor
# Make sure FocalPointPlacticity plugin is loaded
# Arguments are cell: CellG lambda_distance: float, target_distance: float, max_distance: float
# You can specify an anchor point with (float) keyword arguments "x", "y", "z" or with a (Point3D) keyword argument "pt"
# link = self.new_fpp_anchor(cell, lambda_distance, target_distance, max_distance, x=0.0, y=1.0, z=2.0)
# link = self.new_fpp_anchor(cell, lambda_distance, target_distance, max_distance, pt=Point3D(0, 1, 2))

----------  # @Submenu@ Link management: Delete FPP Link (any type)
self.delete_fpp_link(link)

----------  # @Submenu@ Link management: Delete FPP Links Attached to a Cell (any type)
# To select which types of links to remove, set any of the following keyword arguments to True
#   Remove all links          : links
#   Remove all internal links : internal_links
#   Remove all anchors        : anchors
# If none of these are specified, then all links of any type are removed
self.remove_all_cell_fpp_links(cell)

----------  # @Submenu@ Link inventory: Get number of links
# Make sure FocalPointPlacticity plugin is loaded
nl = self.get_number_of_fpp_links()

----------  # @Submenu@ Link inventory: Get number of internal links
# Make sure FocalPointPlacticity plugin is loaded
nil = self.get_number_of_fpp_internal_links()

----------  # @Submenu@ Link inventory: Get number of anchors
# Make sure FocalPointPlacticity plugin is loaded
na = self.get_number_of_fpp_anchors()

----------  # @Submenu@ Link inventory: Get link associated with two cells
# Make sure FocalPointPlacticity plugin is loaded
link = self.get_fpp_link_by_cells(cell1, cell2)

----------  # @Submenu@ Link inventory: Get internal link associated with two cells
# Make sure FocalPointPlacticity plugin is loaded
link = self.get_fpp_internal_link_by_cells(cell1, cell2)

----------  # @Submenu@ Link inventory: Get anchor assicated with a cell and anchor id
# Make sure FocalPointPlacticity plugin is loaded
link = self.get_fpp_anchor_by_cell_and_id(cell, anchor_id)

----------  # @Submenu@ Link inventory: Get number of link junctions by type for a cell
# Make sure FocalPointPlacticity plugin is loaded
njt = self.get_number_of_fpp_junctions_by_type(cell, attached_cell_type)

----------  # @Submenu@ Link inventory: Get number of internal link junctions by type for a cell
# Make sure FocalPointPlacticity plugin is loaded
nijt = self.get_number_of_fpp_internal_junctions_by_type(cell, attached_cell_type)

----------  # @Submenu@ Visit: All links attached to a cell
# Make sure FocalPointPlacticity plugin is loaded
# Visit all links attached to a cell
for link in self.get_fpp_links_by_cell(cell):
    # operations here

----------  # @Submenu@ Visit: All internal links attached to a cell
# Make sure FocalPointPlacticity plugin is loaded
# Visit all internal links attached to a cell in a cluster
for link in self.get_fpp_internal_links_by_cell(cell):
    # operations here

----------  # @Submenu@ Visit: All anchors attached to a cell
# Make sure FocalPointPlacticity plugin is loaded
# Visit all anchors attached to a cell
for link in self.get_fpp_anchors_by_cell(cell):
    # operations here

----------  # @Submenu@ Visit: All cells attached to a cell by a link
# Make sure FocalPointPlacticity plugin is loaded
# Visit all cells attached to a cell by a link
for linked_cell in self.get_fpp_linked_cells(cell):
    # operations here

----------  # @Submenu@ Visit: All cells attached to a cell by an internal link
# Make sure FocalPointPlacticity plugin is loaded
# Visit all cells attached to a cell by an internal link
for linked_cell in self.get_fpp_internal_linked_cells(cell):
    # operations here

===============  # @Menu@ Adhesion Flex

----------  # @Submenu@ Get Molecule Dens. By Name
# Make sure AdhesionFlex plugin is loaded
# accessing adhesion molecule density using its name
self.adhesionFlexPlugin.getAdhesionMoleculeDensity(cell, "NCad")

----------  # @Submenu@ Get Molecule Dens. By Index
# Make sure AdhesionFlex plugin is loaded
# accessing adhesion molecule density using its index
# molecules are indexed in the same order they are listed in the xml file
self.adhesionFlexPlugin.getAdhesionMoleculeDensity(cell,0)

----------  # @Submenu@ Set Molecule Dens. By Name
# Make sure AdhesionFlex plugin is loaded
# setting adhesion molecule density using its name
self.adhesionFlexPlugin.setAdhesionMoleculeDensity(cell, "NCad", 11.2)

----------  # @Submenu@ Set Molecule Dens. By Index
# Make sure AdhesionFlex plugin is loaded
# setting adhesion molecule density using its index
# molecules are indexed in the same order they are listed in the xml file
self.adhesionFlexPlugin.setAdhesionMoleculeDensity(cell, 0, 11.2)

----------  # @Submenu@  Get Molecule Dens. By Name (Medium)
# Make sure AdhesionFlex plugin is loaded
# accessing adhesion molecule density for Medium using its name
self.adhesionFlexPlugin.getMediumAdhesionMoleculeDensity("NCad")

----------  # @Submenu@  Get Molecule Dens. By Index (Medium)
# Make sure AdhesionFlex plugin is loaded
# accessing adhesion molecule density for Medium using its index
# molecules are indexed in the same order they are listed in the xml file
self.getMediumAdhesionMoleculeDensityByIndex(0)

----------  # @Submenu@  Set Molecule Dens. By Name (Medium)
# Make sure AdhesionFlex plugin is loaded
# setting adhesion molecule density for Medium using its name
self.adhesionFlexPlugin.setMediumAdhesionMoleculeDensity("NCad", 11.2)

----------  # @Submenu@  Set Molecule Dens. By Index (Medium)
# Make sure AdhesionFlex plugin is loaded
# setting adhesion molecule density for Medium using its index
# molecules are indexed in the same order they are listed in the xml file
self.adhesionFlexPlugin.setMediumAdhesionMoleculeDensityByIndex(0, 11.2)

===============  # @Menu@ Chemotaxis

----------  # @Submenu@  By Cell Id (Define)
# Make sure Chemotaxis Plugin is loaded
# defining chemotaxis properties of individual cell 'cell'
cd = self.chemotaxisPlugin.addChemotaxisData(cell, "FIELDNAME")
cd.setLambda(20.0)
# If assigning chemotaxis only towards one or more specific cell types, then use the following,
# where the list references the cell types (shown here for type names 'type_name_1' and 'type_name_2')
# cd.assignChemotactTowardsVectorTypes([self.cell_type.type_name_1, self.cell_type.type_name_2])

----------  # @Submenu@  By Cell Id (Modify)
# Make sure Chemotaxis Plugin is loaded
# modifying chemotaxis properties of individual cell 'cell'
cd = self.chemotaxisPlugin.getChemotaxisData(cell, "FIELDNAME")
if cd:
    l = cd.getLambda() - 3
    cd.setLambda(l)

===============  # @Menu@ Inertia Tensor

----------  # @Submenu@ Information
# Make sure MomentOfInertia plugin is loaded
print("cell.iXX=", cell.iXX, " cell.iYY=", cell.iYY, " cell.iXY=", cell.iXY)
# simiilarly we can get other components of intertia tensor

----------  # @Submenu@ Semiaxes
# Make sure MomentOfInertia plugin is loaded
axes = self.momentOfInertiaPlugin.getSemiaxes(cell)
print("minorAxis=", axes[0], " majorAxis=", axes[2], " medianAxis=", axes[1])

===============  # @Menu@ Elasticity

----------  # @Submenu@ Modify Existing Links
# Make sure Elasticity plugin is loaded and Local option is on
elasticity_data_list = self.get_elasticity_data_list(cell)
for elasticity_data in elasticity_data_list:  # visiting all elastic links of 'cell'

    target_length = elasticity_data.targetLength
    elasticity_data.targetLength = 6.0
    elasticity_data.lambdaLength = 200.0
    elasticity_neighbor = elasticity_data.neighborAddress

    # now we set up elastic link data stored in neighboring cell
    neighbor_elasticity_data = None
    neighbor_elasticity_data_list = self.get_elasticity_data_list(elasticity_neighbor)
    for neighbor_elasticity_data_tmp in neighbor_elasticity_data_list:
        if not self.are_cells_different(neighbor_elasticity_data_tmp.neighborAddress, cell):
            neighbor_elasticity_data = neighbor_elasticity_data_tmp
            break

    if neighbor_elasticity_data is None:
        print ("None Type returned."
               " Problems with ElasticityDataNeighbors initialization or sets of elasticityNeighborData are corrupted")
        sys.exit()
    neighbor_elasticity_data.targetLength = 6.0
    neighbor_elasticity_data.lambdaLength = 200.0

----------  # @Submenu@ Add New Elastic Link
# Make sure Elasticity plugin is loaded and Local option is on
# arguments are cell1, cell2, lambdaElasticLink,targetLinkLength
self.elasticityTrackerPlugin.addNewElasticLink(cell1, cell2, 200.0, 6.0)

----------  # @Submenu@ Remove Elastic Link
# Make sure Elasticity plugin is loaded and Local option is on
# arguments are cell1, cell2,
self.elasticityTrackerPlugin.removeElasticityPair(cell1, cell2, 200.0, 6.0)

===============  # @Menu@ Secretion / Uptake

----------  # @Submenu@ Secrete Inside Cell
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteInsideCell(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteInsideCellAtBoundary(cell, 300)

----------  # @Submenu@ Secrete Outside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteOutsideCellAtBoundary(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At COM
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteInsideCellAtCOM(cell, 300)

----------  # @Submenu@ Secrete Inside Cell Constant Concentration
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")
secretor.secreteInsideCellConstantConcentration(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At Boundary On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, secretion rate, a list of cell types
secretor.secreteInsideCellConstantConcentration(cell, 300, [self.TYPE1, self.TYPE2])

----------  # @Submenu@ Secrete Outside Cell At Boundary On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, secretion rate, a list of cell types
secretor.secreteOutsideCellConstantConcentration(cell, 300, [self.TYPE1, self.TYPE2])

----------  # @Submenu@ Uptake Inside Cell
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake
secretor.uptakeInsideCell(cell, 2.0, 0.2)

----------  # @Submenu@ Uptake Inside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake
secretor.uptakeInsideCellAtBoundary(cell, 2.0, 0.2)

----------  # @Submenu@ Uptake Outside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake
secretor.uptakeInsideCellAtBoundary(cell, 2.0, 0.2)

----------  # @Submenu@ Uptake Inside Cell At COM
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake
secretor.uptakeInsideCellAtCOM(cell, 2.0, 0.2)

----------  # @Submenu@ Uptake Inside Cell At Boundary and On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake, a list of cell types
secretor.uptakeInsideCellAtBoundaryOnContactWith(cell, 2.0, 0.2, [self.TYPE1, TYPE2])

----------  # @Submenu@ Uptake Outside Cell At Boundary and On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
# you may reuse secretor for many cells. Simply define it outside the loop
secretor = self.get_field_secretor("FIELDNAME")

# arguments are: cell, max uptake, relative uptake, a list of cell types
secretor.uptakeOutsideCellAtBoundaryOnContactWith(cell, 2.0, 0.2, [self.TYPE1, TYPE2])

===============  # @Menu@ Extra Fields Automatic Tracking

----------  # @Submenu@  Track Scalar Cell Attribute (__init__)
self.track_cell_level_scalar_attribute(field_name='FIELD_NAME', attribute_name='ATTR_NAME')

----------  # @Submenu@  Track Scalar Cell Attribute Custom Function (__init__)
self.track_cell_level_scalar_attribute(field_name='FIELD_NAME', attribute_name='ATTR_NAME',
                                       function=lambda attr_val: attr_val ** 3)

----------  # @Submenu@  Track Vector Cell Attribute (__init__)
self.track_cell_level_vector_attribute(field_name='mcs_vec', attribute_name='mcs_vec')

----------  # @Submenu@  Track Vector Cell Attribute Custom Function (__init__)
self.track_cell_level_vector_attribute(field_name='FIELD_NAME', attribute_name='VEC_NAME',
                                       function=lambda vec: [vec[0] * random(), vec[1] * random(), vec[2] * random()])

===============  # @Menu@ Extra Fields

----------  # @Submenu@  Scalar Field Cell Level - Example
from random import random
field = self.field.SCALAR_CL_FIELD

# clear field
field.clear()

for cell in self.cell_list:
    field[cell] = cell, cell.id * random()

----------  # @Submenu@ Scalar Field Cell Level - Create (__init__ fcn.)
self.create_scalar_field_cell_level_py("FIELD_NAME_SCL")

----------  # @Submenu@ Scalar Field Cell Level - Clear (step fcn.)
field = self.field.SCALAR_CL_FIELD.clear()

----------  # @Submenu@ Scalar Field Cell Level - Write (step fcn.)
field = self.field.SCALAR_CL_FIELD
field[cell] = FLOAT_VALUE

----------  # @Submenu@ Scalar Field Pixel Level - Example
import math
field = self.field.SCALAR_FIELD

# clear field
field[:, :, :] = 0.0

for x, y, z in self.every_pixel():
    if not mcs % 20:
        field[x, y, z] = x * y

    else:
        field[x, y, z] = math.sin(x * y)

----------  # @Submenu@ Scalar Field Pixel Level - Create (__init__ fcn.)
self.create_scalar_field_py("FIELD_NAME_S")

----------  # @Submenu@ Scalar Field Pixel Level - Clear (step fcn.)
field = self.field.SCALAR_FIELD
field[:, :, :] = 0.0

----------  # @Submenu@ Scalar Field Pixel Level - Write (step fcn.)
field = self.field.SCALAR_FIELD
field[10, 11, 0] = FLOAT_VALUE

----------  # @Submenu@ Vector Field Cell Level - Example
from random import random
field = self.field.VECTOR_CL_FIELD

field.clear()
for cell in self.cell_list:
    if cell.type == 1:
        field[cell] = [cell.id * random(), cell.id * random(), 0]
        vec = field[cell]
        vec *= 2.0
        field[cell] = vec

----------  # @Submenu@ Vector Field Cell Level - Create (__init__ fcn.)
self.create_vector_field_cell_level_py("FIELD_NAME_VCL")

----------  # @Submenu@ Vector Field Cell Level - Clear (step fcn.)
field = self.field.VECTOR_CL_FIELD.clear()

----------  # @Submenu@ Vector Field Cell Level - Write (step fcn.)
field = self.field.VECTOR_CL_FIELD
field[cell] = [VEC_X, VEC_Y, VEC_Z]

----------  # @Submenu@ Vector Field Pixel Level - Example
field = self.field.VECTOR_FIELD
# clear vector field
field[:, :, :, :] = 0.0

for x in range(0, self.dim.x, 5):
    for y in range(0, self.dim.y, 5):
        for z in range(self.dim.z):
            field[x, y, z] = [x * random(), y * random(), z * random()]

----------  # @Submenu@ Vector Field Pixel Level - Create (__init__ fcn.)
self.create_vector_field_py("FIELD_NAME_V")

----------  # @Submenu@ Vector Field Pixel Level - Clear (step fcn.)
field = self.field.VECTOR_FIELD
# clear vector field
field[:, :, :, :] = 0.0

----------  # @Submenu@ Vector Field Pixel Level - Write (step fcn.)
field = self.field.VECTOR_FIELD
field[x, y, z] = [VEC_X, VEC_Y, VEC_Z]

===============  # @Menu@ Scientific Plots

----------  # @Submenu@ 1. Setup (start fcn)

self.plot_win = self.add_new_plot_window(title='Average Volume And Surface',
                                         x_axis_title='MonteCarlo Step (MCS)',
                                         y_axis_title='Variables', x_scale_type='linear', y_scale_type='linear',
                                         grid=False)

self.plot_win.add_plot("MVol", style='Lines', color='red', size=5)
self.plot_win.add_plot("MSur", style='Dots', color='green', size=1)


----------  # @Submenu@ 2. Add Data Points (step fcn)
# arguments are (name of the data series, x, y)
self.plot_win.add_data_point("MVol", mcs, cell.volume)
self.plot_win.add_data_point("MSur", mcs, cell.surface)


----------  # @Submenu@ Erase Plot (step fcn)
self.plot_win.erase_all_data()

----------  # @Submenu@ 3. Refresh Plots (unnecessary, deprecated - step fcn )
self.plot_win.show_all_plots()

----------  # @Submenu@ Save Plot As A PNG File
# here we specify size of the image saved (1000x1000) - default is 400 x 400
# resizing of the image is not guaranteed to be implemented
self.plot_win.save_plot_as_png(file_name, 1000, 1000)

----------  # @Submenu@ Save Plot As Data (text file)
self.plot_win.save_plot_as_data(file_name)

===============  # @Menu@ Scientific Plots Histograms

----------  # @Submenu@ 1. Add Histogram Plot (start fcn)
# initialize setting for Histogram
self.plot_win = self.add_new_plot_window(title='Histogram of Cell Volumes', x_axis_title='Number of Cells',
                                         y_axis_title='Volume Size in Pixels')
# _alpha is transparency 0 is transparent, 255 is opaque
self.plot_win.add_histogram_plot(plot_name='Hist 1', color='green', alpha=100)
self.plot_win.add_histogram_plot(plot_name='Hist 2', color='red', alpha=100)
self.plot_win.add_histogram_plot(plot_name='Hist 3', color='blue')

----------  # @Submenu@ 2. Add Histogram  (step fcn)
self.plot_win.add_histogram(plot_name='Hist 1', value_array=gauss, number_of_bins=10)
self.plot_win.add_histogram(plot_name='Hist 2', value_array=vol_list, number_of_bins=10)
self.plot_win.add_histogram(plot_name='Hist 3', value_array=vol_list, number_of_bins=50)


----------  # @Submenu@ Save  Plot As A PNG File
# here we specify size of the image saved (1000x1000) - default is 400 x 400
# resizing of the image is not guaranteed to be implemented
self.plot_win.save_plot_as_png(file_name, 1000, 1000)

----------  # @Submenu@ Save Plot As Data (text file)
self.plot_win.save_plot_as_data(file_name)

===============  # @Menu@ Simulation

----------  # @Submenu@ Stop Simulation
self.stop_simulation()

----------  # @Submenu@ Set Max MCS
self.set_max_mcs(MAX_MCS)

----------  # @Submenu@ Change Steppable Frequency
self.frequency = NEW_FREQUENCY

----------  # @Submenu@ Build Wall
self.build_wall(self.YOUR_WALL_CELL_TYPE)

----------  # @Submenu@ Destroy Wall
self.destroy_wall()

----------  # @Submenu@ Resize And Shift Lattice
self.resize_and_shift_lattice(new_size=(X, Y, Z), shift_vec=(VX, VY, VZ))

----------  # @Submenu@ Change Number of CPU's (worknodes)
self.change_number_of_work_nodes(8)

----------  # @Submenu@ Shared steppable dictionary
# This dictionary is shared by all registered steppables
self.shared_steppable_vars

===============  # @Menu@ MaBoSS

----------  # @Submenu@ Add a MaBoSS simulation to a cell
# Input MaBoSS network description in file 'bnd_file' or string 'bnd_str'
# Input MaBoSS configuration in file 'cfg_file' or string 'cfg_str'
# If using strings, enclose entire network/configuration in a multiline string
# Input
self.add_maboss_to_cell(cell=cell,
                        model_name=model_name,
                        bnd_file=bnd_file,
                        bnd_str=bnd_str,
                        cfg_file=cfg_file,
                        cfg_str=cfg_str,
                        time_step=1.0,
                        time_tick=1.0,
                        discrete_time=False,
                        seed=0)

----------  # @Submenu@ Create a MaBoSS simulation
# Input MaBoSS network description in file 'bnd_file' or string 'bnd_str'
# Input MaBoSS configuration in file 'cfg_file' or string 'cfg_str'
# If using strings, enclose entire network/configuration in a multiline string
# Input
from cc3d.core import MaBoSSCC3D
mm = MaBoSSCC3D.maboss_model(model_name=model_name,
                             bnd_file=bnd_file,
                             bnd_str=bnd_str,
                             cfg_file=cfg_file,
                             cfg_str=cfg_str,
                             time_step=1.0,
                             time_tick=1.0,
                             discrete_time=False,
                             seed=0)

----------  # @Submenu@ Get a MaBoSS simulation attached to a cell
# 'MyModel' is the alias of the particular model to get e.g., self.add_maboss_to_cell(model_name='MyModel', ...)
mm = cell.maboss.MyModel

----------  # @Submenu@ Delete a MaBoSS model attached to a cell
# 'model_name' contains the alias of the particular model to get e.g., self.add_maboss_to_cell(model_name=model_name, ...)
self.delete_maboss_from_cell(cell=cell, model_name=model_name)

----------  # @Submenu@ Step all attached MaBoSS models
self.timestep_maboss()

----------  # @Submenu@ Get a MaBoSS network node
# 'MyModel' is the alias of the particular model to get e.g., self.add_maboss_to_cell(model_name='MyModel', ...)
# 'MyNode' is the name of the node in the MaBoSS network
node = cell.maboss.MyModel['MyNode']

----------  # @Submenu@ Get/set a MaBoSS network node property
# node is a MaBoSS node
node_description: str = node.description  # Description; read-only
node_is_input: bool = node.is_input  # Input node flag; read-only
node_is_internal: bool = node.is_internal  # Internal node flag
node_is_reference: bool = node.is_reference  # Reference node flag
node_istate: bool = node.istate  # Initial state
node_rate_down: float = node.rate_down  # Current rate down; read-only
node_rate_up: float = node.rate_up  # Current rate up; read-only
node_ref_state: bool = node.ref_state  # Reference state
node_state: bool = node.state  # Current state

----------  # @Submenu@ Get/set a MaBoSS simulation property
# mm is a MaBoSS simulation
mm_time: float = mm.time  # Current simulation time; read-only
mm_step_size: float = mm.step_size  # Step size
mm_time_tick: float = mm.run_config.time_tick  # Time tick
mm_discrete_time: bool = mm.run_config.discrete_time  # Continuous/discrete flag
mm_seed: int = mm.run_config.seed  # Random generator seed

----------  # @Submenu@ Get/set a MaBoSS external variable
# mm is a MaBoSS simulation
# myVar is declared as '$myVar' in the MaBoSS specification
mm_myVar = mm.network.symbol_table['myVar']

----------  # @Submenu@ Copy a MaBoSS network state
# mm_from and mm_to is are MaBoSS simulations
mm_to.loadNetworkState(mm_from.getNetworkState())


===============  # @Menu@ Mitosis

----------  # @Submenu@ 1. Clone Attributes Parent -> Child
self.clone_parent_2_child()

----------  # @Submenu@ 1. Clone Cluster Attributes Parent -> Child
self.clone_parent_cluster_2_child_cluster()

----------  # @Submenu@ 2. Compact updateAttributes
self.parent_cell.targetVolume /= 2.0  # reducing parent target volume
self.clone_parent_2_child()

----------  # @Submenu@ 2. Compact updateAttributes for clusters
# we first redice target volum of the cluster of parent cell
compartment_list_parent = self.get_cluster_cells(self.parent_cell.clusterId)
for i in range(compartment_list_parent.size()):
    compartment_list_parent[i].targetVolume /= 2.0

# later we clone attributes from parent cluster to child cluster
self.clone_parent_cluster_2_child_cluster()

----------  # @Submenu@ Clone Attributes (Flexible)
self.clone_attributes(source_cell=self.parent_cell, target_cell=self.child_cell, no_clone_key_dict_list=[ATTRIB_1, ATTRIB_2])

----------  # @Submenu@ Child/Parent Random Relative Position
self.set_parent_child_position_flag(0)

----------  # @Submenu@ Child on the Left of the Parent
self.set_parent_child_position_flag(1)

----------  # @Submenu@ Child on the Right of the Parent
self.set_parent_child_position_flag(-1)

----------  # @Submenu@ Divide Cells Along Random Axis (Example)
cells_to_divide = []
for cell in self.cell_list:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divide_cell_random_orientation(cell)

----------  # @Submenu@ Divide Cells Along Major Axis (Example)
cells_to_divide = []
for cell in self.cell_list:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divide_cell_along_major_axis(cell)

----------  # @Submenu@ Divide Cells Along Minor Axis (Example)
cells_to_divide = []
for cell in self.cell_list:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divide_cell_along_minor_axis(cell)

----------  # @Submenu@ Divide Cells Along Normal To Vector (Example)
cells_to_divide = []
for cell in self.cell_list:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    # dividing along Y axis - normal to (1,0,0)
    self.divide_cell_orientation_vector_based(cell, 1, 0, 0)

----------  # @Submenu@ Divide Cluster Along Random Axis (Example)
mitosis_cluster_id_list = []
for compartment_list in self.cluster_list:

    cluster_id = 0
    cluster_volume = 0
    for cell in CompartmentList(compartment_list):
        cluster_volume += cell.volume
        cluster_id = cell.clusterId

    # condition under which cluster mitosis takes place
    if cluster_volume > 250:
        # instead of doing mitosis right away we store ids for clusters which should be divide.
        # This avoids modifying cluster list while we iterate through it
        mitosis_cluster_id_list.append(cluster_id)

for cluster_id in mitosis_cluster_id_list:
    self.divide_cluster_random_orientation(cluster_id)

----------  # @Submenu@ Divide Cluster Along Major Axis (Example)
mitosis_cluster_id_list = []
for compartment_list in self.cluster_list:

    cluster_id = 0
    cluster_volume = 0
    for cell in CompartmentList(compartment_list):
        cluster_volume += cell.volume
        cluster_id = cell.clusterId

    # condition under which cluster mitosis takes place
    if cluster_volume > 250:
        # instead of doing mitosis right away we store ids for clusters which should be divide.
        # This avoids modifying cluster list while we iterate through it
        mitosis_cluster_id_list.append(cluster_id)

for cluster_id in mitosis_cluster_id_list:
    self.divide_cluster_along_major_axis(cluster_id)

----------  # @Submenu@ Divide Cluster Along Minor Axis (Example)
mitosis_cluster_id_list = []
for compartment_list in self.clusterList:

    cluster_id = 0
    cluster_volume = 0
    for cell in CompartmentList(compartment_list):
        cluster_volume += cell.volume
        cluster_id = cell.clusterId

    # condition under which cluster mitosis takes place
    if cluster_volume > 250:
        # instead of doing mitosis right away we store ids for clusters which should be divide.
        # This avoids modifying cluster list while we iterate through it
        mitosis_cluster_id_list.append(cluster_id)

for cluster_id in mitosis_cluster_id_list:
    self.divide_cluster_along_major_axis(cluster_id)

----------  # @Submenu@ Divide Cluster Along Normal To Vector (Example)
mitosis_cluster_id_list = []
for compartment_list in self.clusterList:

    cluster_id = 0
    cluster_volume = 0
    for cell in CompartmentList(compartment_list):
        cluster_volume += cell.volume
        cluster_id = cell.clusterId

    # condition under which cluster mitosis takes place
    if cluster_volume > 250:
        # instead of doing mitosis right away we store ids for clusters which should be divide.
        # This avoids modifying cluster list while we iterate through it
        mitosis_cluster_id_list.append(cluster_id)

for cluster_id in mitosis_cluster_id_list:
    self.divideClusterOrientationVectorBased(cluster_id, 1, 0, 0)

===============  # @Menu@ Parameter Scan Command Line

----------  # @Submenu@ 1. Run Parameter Scan Using Player (Windows)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.bat - i < cc3dproject - file > --guiScan --maxNumberOfRuns=20[remaining command
line
options
used in compucell3d.bat or runScript.bat]

----------  # @Submenu@ 1. Run Parameter Scan With No GUI (Windows)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.bat - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.bat or runScript.bat]

----------  # @Submenu@ 2. Run Parameter Scan Using Player (Linux)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.sh - i < cc3d
project - file > --guiScan - -maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.sh or runScript.sh]

----------  # @Submenu@ 2. Run Parameter Scan With No GUI (Linux)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.sh - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.sh or runScript.sh]

----------  # @Submenu@ 3. Run Parameter Scan Using Player (OSX)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.command - i < cc3d
project - file > --guiScan - -maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.command or runScript.command]

----------  # @Submenu@ 3. Run Parameter Scan With No GUI (OSX)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.command - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.command or runScript.command]

----------  # @Submenu@ Current Parameter Scan Iteration
# accessing current parameter scan iteration from steppable
iteration = self.param_scan_iteration
