===============  # @Menu@ Python Utilities

----------  # @Submenu@ Open File In Simulation Output Directory
from pathlib import Path

if self.output_dir is not None:
    output_path = Path(self.output_dir).joinpath("<FILE_NAME>")
    # create folder to store data
    output_path.parent.mkdir(parents=True, exist_ok=True)
    try:
        file_handle = open(output_path, 'w')
    except IOError:
        print ("Could not open file for writing.")
        return

----------  # @Submenu@ Fetch Steppable By Class Name
self.getSteppableByClassName('STEPPABLE_CLASS_NAME')

----------  # @Submenu@ Get Dir Of Current File
fileDir = os.path.dirname(os.path.abspath(__file__))

----------  # @Submenu@ Get FullPath Of Current File
filePath = os.path.abspath(__file__)

----------  # @Submenu@ Import os
import os

----------  # @Submenu@ Set Simulation Output Directory (main Python script)
# It is best to call this function from __init__ of first registered steppable
self.set_output_dir(output_dir="<CUSTOM_OUTPUT_DIR>", abs_path=False)

===============  # @Menu@ SBML Solver

----------  # @Submenu@ 1. Model Initial Data
# this can be e.g. partial path 'Simulation/osci.sbml'
model_file = 'PATH_TO_SBML_MODEL'

initial_conditions = {}
initial_conditions['SPECIES_NAME1'] = species_val1
initial_conditions['SPECIES_NAME2'] = species_val2

step_size = 0.5

----------  # @Submenu@ 2. Add model to cell ids
self.add_sbml_to_cell_ids(model_file=model_file, model_name='MODEL_NAME', cell_ids=[1, 3, 7], step_size=step_size,
                          initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add model to cell types
self.add_sbml_to_cell_types(model_file=model_file, model_name='MODEL_NAME', cell_types=[self.CELLTYPENAME1, self.CELLTYPENAME1],
                        step_size=step_size, initial_conditions=initial_conditions)

----------  # @Submenu@ 2. Add model to individual cell
cell_20 = self.fetch_cell_by_id(20)

if cell_20:
    self.add_sbml_to_cell(model_file=model_file, model_name='MODEL_NAME', cell=cell_20,step_size=step_size,
                          initial_conditions=initial_conditions)


----------  # @Submenu@ 2. Add free floating model e.g. PBPK
self.add_free_floating_sbml(model_file=model_file, model_name='UNIQUE_MODEL_NAME', step_size=step_size,
                            initial_conditions=initial_conditions)

----------  # @Submenu@ 3. Timestep SBML models
self.timestep_sbml()

----------  # @Submenu@ 5. Copy select SBMLs
self.copy_sbml_simulators(from_cell=source_cell, to_cell=target_cell, sbml_names=['MODEL_NAME1', 'MODEL_NAME2'])

----------  # @Submenu@ 5. Copy All SBMLs
self.copy_sbml_simulators(from_cell=source_cell, to_cell=target_cell)

----------  # @Submenu@  Get SBML State for individual cell
# returns dictionary of values
state = cell.sbml.MODELNAME


----------  # @Submenu@  Get SBML State for Free Floating model
state = self.sbml.UNIQUE_MODEL_NAME

----------  # @Submenu@  Get SBML Value for SBML in a specific cell
# value name can be e.g. species name
# example cell.DN.Delta
cell.sbml.MODEL_NAME['VALUE_NAME']

----------  # @Submenu@  Get SBML Value for Free Floating model
# value name can be e.g. species name
self.sbml.MODEL_NAME['VALUE_NAME']

----------  # @Submenu@  Get SBML Simulator for individual cell(advanced)
# example cell.sbml._rr_DN
cell.sbml._rr_MODEL_NAME

----------  # @Submenu@  Get SBML Simulator for Free Floating Model(advanced)
# example self.sbml._rr_DN
self.sbml._rr_MODEL_NAME

----------  # @Submenu@  Set SBML State for individual cell
state = {}
state['REACTANT_NAME'] = 0.9

self.set_sbml_state(model_name='MODELNAME', cell=cell, state=state)

----------  # @Submenu@  Set SBML State for Free Floating model
state = {}
state['REACTANT_NAME'] = 0.9
self.set_sbml_state(model_name='MODELNAME',  state=state)

----------  # @Submenu@  Set SBML Value for SBML in a specific cell
# value name can be e.g. species name
cell.sbml.UNIQUE_MODEL_NAME['VALUE_NAME'] = 0.1

----------  # @Submenu@  Set SBML Value for Free Floating model
# value name can be e.g. species name
self.sbml.UNIQUE_MODEL_NAME['VALUE_NAME'] = 0.1

----------  # @Submenu@  Delete SBML from cell ids
self.delete_sbml_from_cell_ids(model_name='MODEL_NAME', cell_ids=[1, 4, 7])

----------  # @Submenu@  Delete SBML from cell types
self.delete_sbml_from_cell_types(model_name='MODEL_NAME', cell_types=[self.CELLTYPE1, self.CELLTYPE2])

----------  # @Submenu@  Delete SBML from individual cell
self.delete_sbml_from_cell(model_name='MODEL_NAME', cell=cell)

----------  # @Submenu@  Delete Free Floating SBML
self.delete_free_floating_sbml(model_name='UNIQUE_MODEL_NAME')

----------  # @Submenu@  Set SBML Integrator  Global Options
# adding options that setup SBML solver integrator - these are optional but useful when encountering
# integration instabilities
# relative is relative tolerance, absolute is absolute tolerance,
# steps is the initial number of integration steps for each integration interval
# (higher number does not result in slower simulation, quite to the contrary),
# stiff set to true will use stiff ODE solver
options = {'relative': 1e-10, 'absolute': 1e-12, 'steps': 10, 'stiff': False}
self.set_sbml_global_options(options)

----------  # @Submenu@  Get SBML Integrator  Global Options
# returns current options - can be None if no global options were set
options = self.get_sbml_global_options()

===============  # @Menu@ Steering Panel

----------i1  # @Submenu@ 1.Set Up Steering Panel


def add_steering_panel(self):
    self.add_steering_param(name='MY_PARAM_SLIDER', val=20, min_val=0, max_val=100,
                            decimal_precision=2, widget_name='slider')
    self.add_steering_param(name='MY_PARAM_COMBO', val=20, enum=[10,20,30,40,50,60,70,80,90,100],
                                widget_name='combobox')

def process_steering_panel_data(self):
    print ('processing steering panel updates')
    print ('all dirty flag=', self.steering_param_dirty())
    param_slider = self.get_steering_param('MY_PARAM_SLIDER')
    param_combo = self.get_steering_param('MY_PARAM_COMBO')
    print ('updated MY_PARAM_SLIDER=',param_slider)
    print ('updated MY_PARAM_COMBO=', param_combo)

    # IMPORTANT: you may add code here tht updates cell properties based on the
    # values of the parameters from the steering panel. For example:

    # for cell in self.cellList:
    #     cell.targetVolume = param_slider
    #     cell.lambdaVolume = param_combo

----------  # @Submenu@ Get Updated Value of Steering Parameter
my_param = self.get_steering_param('MY_PARAM')

----------  # @Submenu@ Check if Steering Panel Was Updated
updated_flag = self.steering_param_dirty()

===============  # @Menu@ Cell Constraints

----------  # @Submenu@ Change Target Volume
cell.targetVolume = 25

----------  # @Submenu@ Change Lambda Volume
cell.lambdaVolume = 2.0

----------  # @Submenu@ Change Target Surface
cell.targetSurface = 20.0

----------  # @Submenu@ Change Lambda Surface
cell.lambdaSurface = 2.0

----------  # @Submenu@ Apply Force To Cell
# Make sure ExternalPotential plugin is loaded
cell.lambdaVecX = -0.5  # force component pointing along X axis - towards positive X's
cell.lambdaVecY = 0.5  # force component pointing along Y axis - towards negative Y's
cell.lambdaVecZ = 0.0  # force component pointing along Z axis

----------  # @Submenu@ Length Constraint By Cell Id
# Make sure LengthConstraintLocalFlex plugin is loaded
# Argument Order: cell , lambdaLength, targetLength
self.lengthConstraintLocalFlexPlugin.setLengthConstraintData(cell, 20, 20)

----------  # @Submenu@ Connectivity Constraint By Cell Id
# Make sure ConnectivityLocalFlex plugin is loaded
# Argument Order: cell, strength
self.connectivityLocalFlexPlugin.setConnectivityStrength(cell, 10000000)

===============  # @Menu@ Cell Manipulation

----------  # @Submenu@ Fetch Cell By Id
cell = self.fetch_cell_by_id(CELL_ID)

----------  # @Submenu@ Delete Cell
self.delete_cell(cell)

----------  # @Submenu@ Create Cell
# size of cell will be 3x3x1
self.cell_field[10:12, 10:12, 0] = self.new_cell(self.TYPENAME)

----------  # @Submenu@ Create Cell (detailed)
x = X_POSITION
y = Y_POSITION
size = SIZE
cell = self.new_cell(self.TYPENAME)
# size of cell will be SIZExSIZEx1
self.cell_field[x:x + size - 1, y:y + size - 1, 0] = cell

----------  # @Submenu@ Get Cell At a Pixel
cell = self.cell_field[10, 11, 0]

----------  # @Submenu@ Move Cell
# Shifting entire cell by a 'shiftVector'         
shift_vector = [20, 20, 0]
self.move_cell(cell, shift_vector)

===============  # @Menu@ Distances, Vectors, Transformations

----------  # @Submenu@ Distance Vector Between Cells
vec = self.distance_between_cells(CELL1, CELL2)

----------  # @Submenu@ Distance Vector Between Cells (Invariant)
vec = self.invariantDistanceVectorBetweenCells(CELL1, CELL2)

----------  # @Submenu@ Distance  Between Cells
vec = self.distanceBetweenCells(CELL1, CELL2)

----------  # @Submenu@ Distance  Between Cells (Invariant)
vec = self.invariantDistanceBetweenCells(CELL1, CELL2)

----------  # @Submenu@ Distance Vector Between Points
vec = self.distance(_from=[10, 10, 0], _to=[11, 11, 0])

----------  # @Submenu@ Distance Vector Between Points (Invariant)
vec = self.invariantDistanceVector(_from=[10, 10, 0], _to=[11, 11, 0])

----------  # @Submenu@ Distance Vector Between Points (Invariant, Integer)
vec = self.invariantDistanceVectorInteger(_from=[10, 10, 0], _to=[11, 11, 0])

----------  # @Submenu@ Vector Norm
norm = self.vectorNorm(VECTOR)

----------  # @Submenu@ Hex: Hex 2 Cartesian
pt = self.hex2Cartesian(_in=COORDS)  # returns Point3D

----------  # @Submenu@ Hex: Cartesian 2 Hex
coords = self.cartesian2Hex(_in=POINT3D)  # retutns Coordinates<double>

----------  # @Submenu@ Numpy: Point3D To Numpy Array
ptArray = self.point3DToNumpy(PT)

----------  # @Submenu@ Numpy: Numpy Array To Point3D
pt = self.numpyToPoint3D(PT_ARRAY)

----------  # @Submenu@ Hex: Cartesian 2 Hex
coords = self.cartesian2Hex(_in=POINT3D)  # retutns Coordinates<double>

===============  # @Menu@ Visit

----------  # @Submenu@ All Cells
# iterating over all cells in simulation        
for cell in self.cellList:
    # you can access/manipulate cell properties here
    print "id=", cell.id, " type=", cell.type, " volume=", cell.volume

----------  # @Submenu@ All Cells Of Given Type
# iterating over cells of type 1        
for cell in self.cellListByType(self.TYPENAME_1, self.TYPENAME_2, ...):  # list of  cell types (capitalized)
    # you can access/manipulate cell properties here
    print "id=", cell.id, " type=", cell.type

----------  # @Submenu@ Cell Neighbors
for neighbor, commonSurfaceArea in self.getCellNeighborDataList(cell):
    if neighbor:
        print "neighbor.id", neighbor.id, " commonSurfaceArea=", commonSurfaceArea
    else:
        print "Medium commonSurfaceArea=", commonSurfaceArea

----------  # @Submenu@ Cell Boundary Pixels
# Make sure BoundaryPixelTracker plugin is loaded
pixelList = self.getCellBoundaryPixelList(cell)
for boundaryPixelTrackerData in pixelList:
    print "pixel of cell id=", cell.id, " type:", cell.type, " = ", boundaryPixelTrackerData.pixel, " number of pixels=", pixelList.numberOfPixels()

----------  # @Submenu@ Cell Pixels
# Make sure PixelTracker plugin is loaded
pixelList = self.getCellPixelList(cell)
for pixelTrackerData in pixelList:
    print "pixel of cell id=", cell.id, " type:", cell.type, " = ", pixelTrackerData.pixel, " number of pixels=", pixelList.numberOfPixels()

----------  # @Submenu@ All Lattice Pixels
for x, y, z in self.everyPixel():
    print "x,y,z=", (x, y, z)

----------  # @Submenu@ All Clusters
for compartments in self.clusters:
    print 'compartments=', compartments

----------  # @Submenu@ All Clusters and Cells Withing Clusters
for compartments in self.clusters:
    for cell in compartments:
        print cell.id

===============  # @Menu@ Chemical Field Manipulation

----------  # @Submenu@ Get Field Reference
field = self.getConcentrationField('FIELD_NAME')

----------  # @Submenu@ Get Field Min Value
minValue = field.min()

----------  # @Submenu@ Get Field Max Value
maxValue = field.max()

----------  # @Submenu@ Get Field Value
value = field[10, 10, 0]

----------  # @Submenu@ Set Field Value
field[10, 10, 0] = 1.02

----------  # @Submenu@ Write To Disk
fileName = 'TYPE YOUR FILE NAME HERE'
field = self.getConcentrationField("NAME OF THE FIELD TO OUTPUT")
if field:
    try:
        import CompuCellSetup

        fileHandle, fullFileName = self.openFileInSimulationOutputDirectory(fileName, "w")
    except IOError:
        print "Could not open file ", fileName, " for writing. Check if you have necessary permissions"

    for i, j, k in self.everyPixel():
        fileHandle.write("%d\t%d\t%d\t%f\n" % (i, j, k, field[i, j, k]))

    fileHandle.close()

----------  # @Submenu@ Modification (aka secretion)
field = self.getConcentrationField("NAME OF THE FIELD ")
if field:
    for i, j, k in self.everyPixel():
        field[i, j, k] = i * j

===============  # @Menu@ Cell Attributes

----------  # @Submenu@ Check If Two Cells Are Different
self.areCellsDifferent(cell1, cell2)

----------  # @Submenu@ Access/Modify Dictionary Attribute
# access/modification of a dictionary attached to cell - make sure to decalare in main script that you will use such attribute
cell.dict['ATTR_NAME'] = VALUE_OR_OBJECT

----------  # @Submenu@ Access/Modify Dictionary Attribute (old style)
# access/modification of a dictionary attached to cell - make sure to decalare in main script that you will use such attribute
cellDict = self.getDictionaryAttribute(cell)
cellDict["Double_MCS_ID"] = mcs * 2 * cell.id
print "cellDict for cell.id=", cell.id, "is ", cellDict

----------  # @Submenu@ Access/Modify Dictionary Attribute (old style)
# access/modification of a dictionary attached to cell - make sure to decalare in main script that you will use such attribute
dict_attrib = CompuCell.getPyAttrib(cell)
dict_attrib["Double_MCS_ID"] = mcs * 2 * cell.id
print "dict attrib for cell.id=", cell.id, "is ", dict_attrib

----------  # @Submenu@ Center Of Mass
# Make sure CenterOfMass plugin is loaded
# READ ONLY ACCESS
xCOM = cell.xCOM
yCOM = cell.yCOM
zCOM = cell.zCOM

----------  # @Submenu@ Volume
# READ ONLY ACCESS        
volume = cell.volume

----------  # @Submenu@ Target Volume
# READ/WRITE  ACCESS                
targetVolume = cell.targetVolume

----------  # @Submenu@ Lambda Volume
# READ/WRITE  ACCESS        
lambdaVolume = cell.lambdaVolume

----------  # @Submenu@ Surface
# READ ONLY ACCESS        
Surface = cell.surface

----------  # @Submenu@ Target Surface
# READ/WRITE  ACCESS                
targetSurface = cell.targetSurface

----------  # @Submenu@ Lambda Surface
# READ/WRITE  ACCESS        
lambdaSurface = cell.lambdaSurface

----------  # @Submenu@ Id
# READ ONLY ACCESS        
id = cell.id

----------  # @Submenu@ Cluster Id
# READ ONLY ACCESS - can be modified using reassignClusterId function        
clusterId = cell.clusterId

----------  # @Submenu@ Cluster Id Reassignment
# You cannot simply set cluster Id on a cell to make t belong to other cluster you have to use the following function call
reassignIdFlag = self.inventory.reassignClusterId(cell, 1536)  # changing cluster id to 1536 for cell 'cell'

----------  # @Submenu@ Cell Type
# READ/WRITE  ACCESS                
type = cell.type

----------  # @Submenu@ Fluctuation Ampl
# READ/WRITE  ACCESS                        
fluctAmpl = cell.fluctAmpl

----------  # @Submenu@ Fluctuation Ampl Reassignment
cell.fluctAmpl = 50
# uncomment line below to use globally defined FluctuationAmplitude
# cell.fluctAmpl=-1

----------  # @Submenu@ Inertia Tensor
# READ ONLY ACCESS        
iXX = cell.iXX
iYY = cell.iYY
iZZ = cell.iZZ
iXY = cell.iXY
iXZ = cell.iXZ
iYZ = cell.iYZ
eccentricity = cell.ecc

===============  # @Menu@ Focal Point Placticity

----------  # @Submenu@ Properties
# Make sure FocalPointPlacticity plugin is loaded
# visiting all focal links cell 'cell' has with other cells
for fppd in self.getFocalPointPlasticityDataList(cell):
    print "fppd.neighborId", fppd.neighborAddress.id, " lambda=", fppd.lambdaDistance, " targetDistance=", fppd.targetDistance
    self.focalPointPlasticityPlugin.setFocalPointPlasticityParameters(cell, fppd.neighborAddress, 1.0, 7.0,
                                                                      20.0)  # arguments are (cell1,cell2,lambda,targetDistance,maxDistance)

----------  # @Submenu@ Properties (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
# visiting all focal links cell 'cell' has with other cells
for fppd in self.getInternalFocalPointPlasticityDataList(cell):
    print "fppd.neighborId", fppd.neighborAddress.id, " lambda=", fppd.lambdaDistance, " targetDistance=", fppd.targetDistance
    self.focalPointPlasticityPlugin.setInternalFocalPointPlasticityParameters(cell, fppd.neighborAddress, 1.0, 7.0,
                                                                              20.0)  # arguments are (cell1,cell2,lambda,targetDistance,maxDistance)

----------  # @Submenu@ Create FPP Link
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.createFocalPointPlasticityLink(CELL1, CELL2, LAMBDA, TARGET_DISTANCE, MAX_DISTANCE)

----------  # @Submenu@ Create FPP Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.createInternalFocalPointPlasticityLink(CELL1, CELL2, LAMBDA, TARGET_DISTANCE,
                                                                       MAX_DISTANCE)

----------  # @Submenu@ Get Lambda for FPP Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.getPlasticityParametersLambdaDistance(CELL1, CELL2)

----------  # @Submenu@ Get Target Distance for FPP Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.getPlasticityParametersTargetDistance(CELL1, CELL2)

----------  # @Submenu@ Delete FPP Link
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.deleteFocalPointPlasticityLink(CELL1, CELL2)

----------  # @Submenu@ Delete FPP Link (Within Cluster)
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.deleteInternalFocalPointPlasticityLink(CELL1, CELL2)

----------  # @Submenu@ Create Anchor
# Make sure FocalPointPlacticity plugin is loaded
anchorId = self.focalPointPlasticityPlugin.createAnchor(CELL, LAMBDA, TARGET_DISTANCE, MAX_DISTANCE, ANCHOR_X, ANCHOR_Y,
                                                        ANCHOR_Z)

----------  # @Submenu@ Delete Anchor
# Make sure FocalPointPlacticity plugin is loaded
self.focalPointPlasticityPlugin.deleteAnchor(CELL, ANCHOR_ID)

----------  # @Submenu@ Set Anchor Parameters
self.focalPointPlasticityPlugin.setAnchorParameters(CELL, ANCHOR_ID, LAMBDA, TARGET_DISTANCE, MAX_DISTANCE, ANCHOR_X,
                                                    ANCHOR_Y, ANCHOR_Z)

===============  # @Menu@ Adhesion Flex

----------  # @Submenu@ Get Molecule Dens. By Name
# Make sure AdhesionFlex plugin is loaded
self.adhesionFlexPlugin.getAdhesionMoleculeDensity(cell, "NCad")  # accessing adhesion molecule density using its name

----------  # @Submenu@ Get Molecule Dens. By Index
# Make sure AdhesionFlex plugin is loaded
self.adhesionFlexPlugin.getAdhesionMoleculeDensity(cell,
                                                   0)  # accessing adhesion molecule density using its index - molecules are indexed in the sdame order they are listed in the xml file

----------  # @Submenu@ Set Molecule Dens. By Name
# Make sure AdhesionFlex plugin is loaded
self.adhesionFlexPlugin.setAdhesionMoleculeDensity(cell, "NCad",
                                                   11.2)  # setting adhesion molecule density using its name

----------  # @Submenu@ Set Molecule Dens. By Index
# Make sure AdhesionFlex plugin is loaded
self.adhesionFlexPlugin.setAdhesionMoleculeDensity(cell, 0,
                                                   11.2)  # setting adhesion molecule density using its index - molecules are indexed in the sdame order they are listed in the xml file

----------  # @Submenu@  Get Molecule Dens. By Name (Medium)
# Make sure AdhesionFlex plugin is loaded
self.adhesionFlexPlugin.getMediumAdhesionMoleculeDensity(
    "NCad")  # accessing adhesion molecule density for Medium using its name

----------  # @Submenu@  Get Molecule Dens. By Index (Medium)
# Make sure AdhesionFlex plugin is loaded
self.getMediumAdhesionMoleculeDensityByIndex(
    0)  # accessing adhesion molecule density for Medium using its index - molecules are indexed in the sdame order they are listed in the xml file

----------  # @Submenu@  Set Molecule Dens. By Name (Medium)
# Make sure AdhesionFlex plugin is loaded
self.adhesionFlexPlugin.setMediumAdhesionMoleculeDensity("NCad",
                                                         11.2)  # setting adhesion molecule density for Medium using its name

----------  # @Submenu@  Set Molecule Dens. By Index (Medium)
# Make sure AdhesionFlex plugin is loaded
self.adhesionFlexPlugin.setMediumAdhesionMoleculeDensityByIndex(0,
                                                                11.2)  # setting adhesion molecule density for Medium using its index - molecules are indexed in the sdame order they are listed in the xml file

===============  # @Menu@ Chemotaxis

----------  # @Submenu@  By Cell Id (Define)
# Make sure Chemotaxis Plugin is loaded
# defining chemotaxis properties of individual cell 'cell'
cd = self.chemotaxisPlugin.addChemotaxisData(cell, "FIELDNAME")
cd.setLambda(20.0)
# cd.initializeChemotactTowardsVectorTypes("Bacterium,Medium")
cd.assignChemotactTowardsVectorTypes([0, 1])

----------  # @Submenu@  By Cell Id (Modify)
# Make sure Chemotaxis Plugin is loaded
# modifying chemotaxis properties of individual cell 'cell'
cd = self.chemotaxisPlugin.getChemotaxisData(cell, "FIELDNAME")
if cd:
    l = cd.getLambda() - 3
    cd.setLambda(l)

===============  # @Menu@ Inertia Tensor

----------  # @Submenu@ Information
# Make sure MomentOfInertia plugin is loaded
print "cell.iXX=", cell.iXX, " cell.iYY=", cell.iYY, " cell.iXY=", cell.iXY
# simiilarly we can get other components of intertia tensor

----------  # @Submenu@ Semiaxes
# Make sure MomentOfInertia plugin is loaded
axes = self.momentOfInertiaPlugin.getSemiaxes(cell)
print "minorAxis=", axes[0], " majorAxis=", axes[2], " medianAxis=", axes[1]

===============  # @Menu@ Elasticity

----------  # @Submenu@ Modify Existing Links
# Make sure Elasticity plugin is loaded and Local option is on
elasticityDataList = self.getElasticityDataList(cell)
for elasticityData in elasticityDataList:  # visiting all elastic links of 'cell'

    targetLength = elasticityData.targetLength
    elasticityData.targetLength = 6.0
    elasticityData.lambdaLength = 200.0
    elasticityNeighbor = elasticityData.neighborAddress

    # now we set up elastic link data stored in neighboring cell
    neighborElasticityData = None
    neighborElasticityDataList = self.getElasticityDataList(elasticityNeighbor)
    for neighborElasticityDataTmp in neighborElasticityDataList:
        if not CompuCell.areCellsDifferent(neighborElasticityDataTmp.neighborAddress, cell):
            neighborElasticityData = neighborElasticityDataTmp
            break

    if neighborElasticityData is None:
        print "None Type returned. Problems with FemDataNeighbors initialization or sets of elasticityNeighborData are corrupted"
        sys.exit()
    neighborElasticityData.targetLength = 6.0
    neighborElasticityData.lambdaLength = 200.0

----------  # @Submenu@ Add New Elastic Link
# Make sure Elasticity plugin is loaded and Local option is on
self.elasticityTrackerPlugin.addNewElasticLink(cell1, cell2, 200.0,
                                               6.0)  # arguments are cell1, cell2, lambdaElasticLink,targetLinkLength

----------  # @Submenu@ Remove Elastic Link
# Make sure Elasticity plugin is loaded and Local option is on
self.elasticityTrackerPlugin.removeElasticityPair(cell1, cell2, 200.0, 6.0)  # arguments are cell1, cell2,

===============  # @Menu@ Secretion / Uptake

----------  # @Submenu@ Secrete Inside Cell
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.secreteInsideCell(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.secreteInsideCellAtBoundary(cell, 300)

----------  # @Submenu@ Secrete Outside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.secreteOutsideCellAtBoundary(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At COM
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.secreteInsideCellAtCOM(cell, 300)

----------  # @Submenu@ Secrete Inside Cell Constant Concentration
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.secreteInsideCellConstantConcentration(cell, 300)

----------  # @Submenu@ Secrete Inside Cell At Boundary On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.secreteInsideCellConstantConcentration(cell, 300, [self.TYPE1,
                                                            self.TYPE2])  # arguments are: cell, secretion rate, a list of cell types

----------  # @Submenu@ Secrete Outside Cell At Boundary On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.secreteOutsideCellConstantConcentration(cell, 300, [self.TYPE1,
                                                             self.TYPE2])  # arguments are: cell, secretion rate, a list of cell types

----------  # @Submenu@ Uptake Inside Cell
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.uptakeInsideCell(cell, 2.0, 0.2)  # arguments are: cell, max uptake, relative uptake

----------  # @Submenu@ Uptake Inside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.uptakeInsideCellAtBoundary(cell, 2.0, 0.2)  # arguments are: cell, max uptake, relative uptake

----------  # @Submenu@ Uptake Outside Cell At Boundary
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.uptakeInsideCellAtBoundary(cell, 2.0, 0.2)  # arguments are: cell, max uptake, relative uptake

----------  # @Submenu@ Uptake Inside Cell At COM
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.uptakeInsideCellAtCOM(cell, 2.0, 0.2)  # arguments are: cell, max uptake, relative uptake

----------  # @Submenu@ Uptake Inside Cell At Boundary and On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.uptakeInsideCellAtBoundaryOnContactWith(cell, 2.0, 0.2, [self.TYPE1,
                                                                  TYPE2])  # arguments are: cell, max uptake, relative uptake, a list of cell types

----------  # @Submenu@ Uptake Outside Cell At Boundary and On Contact With
# Make sure Secretion plugin is loaded
# make sure this field is defined in one of the PDE solvers
secretor = self.getFieldSecretor(
    "FIELDNAME")  # you may reuse secretor for many cells. Simply define it outside the loop
secretor.uptakeOutsideCellAtBoundaryOnContactWith(cell, 2.0, 0.2, [self.TYPE1,
                                                                   TYPE2])  # arguments are: cell, max uptake, relative uptake, a list of cell types

===============  # @Menu@ Extra Fields Automatic Tracking

----------  # @Submenu@  Track Scalar Cell Attribute (__init__)
self.track_cell_level_scalar_attribute(field_name='FIELD_NAME', attribute_name='ATTR_NAME')

----------  # @Submenu@  Track Scalar Cell Attribute Custom Function (__init__)
self.track_cell_level_scalar_attribute(field_name='FIELD_NAME', attribute_name='ATTR_NAME',
                                       function=lambda attr_val: attr_val ** 3)

----------  # @Submenu@  Track Vector Cell Attribute (__init__)
self.track_cell_level_vector_attribute(field_name='mcs_vec', attribute_name='mcs_vec')

----------  # @Submenu@  Track Vector Cell Attribute Custom Function (__init__)
self.track_cell_level_vector_attribute(field_name='FIELD_NAME', attribute_name='VEC_NAME',
                                       function=lambda vec: [vec[0] * random(), vec[1] * random(), vec[2] * random()])

===============  # @Menu@ Extra Fields

----------  # @Submenu@  Scalar Field Cell Level - Example
self.scalarCLField.clear()
from random import random

for cell in self.cellList:
    self.scalarCLField[cell] = cell, cell.id * random()

----------  # @Submenu@ Scalar Field Cell Level - Create (__init__ fcn.)
self.scalarCLField = self.createScalarFieldCellLevelPy("FIELD_NAME_SCL")

----------  # @Submenu@ Scalar Field Cell Level - Clear (step fcn.)
self.scalarCLField.clear()

----------  # @Submenu@ Scalar Field Cell Level - Write (step fcn.)
self.scalarCLField[cell] = FLOAT_VALUE

----------  # @Submenu@ Scalar Field Pixel Level - Example
self.scalarField[:, :, :] = 0.0  # clear field
for x, y, z in self.everyPixel():
    if (not mcs % 20):
        self.scalarField[x, y, z] = x * y

    else:
        self.scalarField[x, y, z] = sin(x * y)

----------  # @Submenu@ Scalar Field Pixel Level - Create (__init__ fcn.)
self.scalarField = self.createScalarFieldPy("FIELD_NAME_S")

----------  # @Submenu@ Scalar Field Pixel Level - Clear (step fcn.)
self.scalarField[:, :, :] = 0.0

----------  # @Submenu@ Scalar Field Pixel Level - Write (step fcn.)
self.scalarField[10, 11, 0] = FLOAT_VALUE

----------  # @Submenu@ Vector Field Cell Level - Example
from random import random

self.vectorCLField.clear()
for cell in self.cellList:
    if cell.type == 1:
        self.vectorCLField[cell] = [cell.id * random(), cell.id * random(), 0]
        vec = self.vectorCLField[cell]
        vec *= 2.0
        self.vectorCLField[cell] = vec

----------  # @Submenu@ Vector Field Cell Level - Create (__init__ fcn.)
self.vectorCLField = self.createVectorFieldCellLevelPy("FIELD_NAME_VCL")

----------  # @Submenu@ Vector Field Cell Level - Clear (step fcn.)
self.vectorCLField.clear()

----------  # @Submenu@ Vector Field Cell Level - Write (step fcn.)
self.vectorCLField[cell] = [VEC_X, VEC_Y, VEC_Z]

----------  # @Submenu@ Vector Field Pixel Level - Example
self.vectorField[:, :, :, :] = 0.0  # clear vector field
for x in xrange(0, self.dim.x, 5):
    for y in xrange(0, self.dim.y, 5):
        for z in xrange(self.dim.z):
            self.vectorField[x, y, z] = [x * random(), y * random(), z * random()]

----------  # @Submenu@ Vector Field Pixel Level - Create (__init__ fcn.)
self.vectorField = self.createVectorFieldPy("FIELD_NAME_V")

----------  # @Submenu@ Vector Field Pixel Level - Clear (step fcn.)
self.vectorField[:, :, :, :] = 0.0  # clear vector field

----------  # @Submenu@ Vector Field Pixel Level - Write (step fcn.)
self.vectorField[x, y, z] = [VEC_X, VEC_Y, VEC_Z]

===============  # @Menu@ Scientific Plots


----------  # @Submenu@ Setup (start fcn) - detailed, old style
import CompuCellSetup

self.pW = CompuCellSetup.viewManager.plotManager.getNewPlotWindow()
if not self.pW:
    return
# Plot Title - properties
self.pW.setTitle("PLOT TITLE")
self.pW.setTitleSize(12)
self.pW.setTitleColor("Green")  # you may choose different color - type its name

# plot background
self.pW.setPlotBackgroundColor("orange")  # you may choose different color - type its name

# properties of x axis
self.pW.setXAxisTitle("TITLE OF Y AXIS")
self.pW.setXAxisTitleSize(10)
self.pW.setXAxisTitleColor("blue")  # you may choose different color - type its name            

# properties of y axis
self.pW.setYAxisTitle("TITLE OF Y AXIS")
self.pW.setYAxisLogScale()
self.pW.setYAxisTitleSize(10)
self.pW.setYAxisTitleColor("red")  # you may choose different color - type its name                                

# choices for style are NoCurve,Lines,Sticks,Steps,Dots
self.pW.addPlot("DATA_SERIES_1", _style='Dots')
# self.pW.addPlot("DATA SERIES 2",_style='Steps') # you may add more than one data series

# plot MCS
self.pW.changePlotProperty("DATA_SERIES_1", "LineWidth", 5)
self.pW.changePlotProperty("DATA_SERIES_1", "LineColor", "red")

self.pW.addGrid()
# adding automatically generated legend
# default possition is at the bottom of the plot but here we put it at the top
self.pW.addAutoLegend("top")

self.clearFlag = False

----------  # @Submenu@ 1. Setup (start fcn)
self.pW = self.addNewPlotWindow(_title='DATA_SERIES_1 and DATA_SERIES_2', _xAxisTitle='MonteCarlo Step (MCS)',
                                _yAxisTitle='Variables', _xScaleType='linear', _yScaleType='linear')
self.pW.addPlot('DATA_SERIES_1', _style='Dots', _color='red', _size=5)
self.pW.addPlot('DATA_SERIES_2', _style='Steps', _size=1)

----------  # @Submenu@ 2. Add Data Points (step fcn)
self.pW.addDataPoint("DATA_SERIES_1", mcs, mcs * mcs)  # arguments are (name of the data series, x, y)
self.pW.addDataPoint("DATA_SERIES_2", mcs, mcs)  # arguments are (name of the data series, x, y)

----------  # @Submenu@ Erase Plot (step fcn)
self.pW.eraseAllData()

----------  # @Submenu@ 3. Refresh Plots (unnecessary, deprecated - step fcn )
self.pW.showAllPlots()

----------  # @Submenu@ Save Plot As A PNG File
self.pW.savePlotAsPNG(fileName, 1000,
                      1000)  # here we specify size of the image saved (1000x1000) - default is 400 x 400

----------  # @Submenu@ Save Plot As Data (text file)
self.pW.savePlotAsData(fileName)

===============  # @Menu@ Scientific Plots Histograms

----------  # @Submenu@ 1. Add Histogram Plot (start fcn)
self.pW = self.addNewPlotWindow(_title='Histogram', _xAxisTitle='TYPE NAME OF X AXIS',
                                _yAxisTitle='TYPE NAME OF Y AXIS', _xScaleType='linear', _yScaleType='linear')
self.pW.addHistogramPlot(_plotName='Hist 1', _color='green',
                         _alpha=100)  # _alpha is transparency 0 is transparent, 255 is opaque

----------  # @Submenu@ 2. Add Histogram  (step fcn)
self.pW.addHistogram(plot_name='Hist 1', value_array=ARRAY_WITH_VALUES, number_of_bins=20)

----------  # @Submenu@ Add Histogram  (step fcn - alternative)
# n and bins are generated using the follofing numpy 
# (n, bins) = numpy.histogram(list_of_values, bins=10)  
self.pW.addHistPlotData('Hist 1', n, bins)

----------  # @Submenu@ Refresh Histogram Plots (deprecated)
self.pW.showAllHistPlots()

----------  # @Submenu@ Save  Plot As A PNG File
self.pW.savePlotAsPNG(fileName, 1000,
                      1000)  # here we specify size of the image saved (1000x1000) - default is 400 x 400

----------  # @Submenu@ Save Plot As Data (text file)
self.pW.savePlotAsData(fileName)

===============  # @Menu@ Simulation

----------  # @Submenu@ Stop Simulation
self.stopSimulation()

----------  # @Submenu@ Set Max MCS
self.setMaxMCS(MAX_MCS)

----------  # @Submenu@ Change Steppable Frequency
self.frequency = NEW_FREQUENCY

----------  # @Submenu@ Build Wall
self.buildWall(self.YOUR_WALL_CELL_TYPE)

----------  # @Submenu@ Destroy Wall
self.destroyWall()

----------  # @Submenu@ Resize And Shift Lattice
self.resizeAndShiftLattice(_newSize=(X, Y, Z), _shiftVec=(VX, VY, VZ))

----------  # @Submenu@ Change Number of CPU's (worknodes)
self.changeNumberOfWorkNodes(8)

===============  # @Menu@ Mitosis

----------  # @Submenu@ 1. Clone Attributes Parent -> Child
self.cloneParent2Child()

----------  # @Submenu@ 1. Clone Cluster Attributes Parent -> Child
self.cloneParentCluster2ChildCluster()

----------  # @Submenu@ 2. Compact updateAttributes
self.parentCell.targetVolume /= 2.0  # reducing parent target volume
self.cloneParent2Child()

----------  # @Submenu@ 2. Compact updateAttributes for clusters
# we first redice target volum of the cluster of parent cell
compartmentListParent = self.getClusterCells(self.parentCell.clusterId)
for i in xrange(compartmentListParent.size()):
    compartmentListParent[i].targetVolume /= 2.0

# later we clone attributes from parent cluster to child cluster
self.cloneParentCluster2ChildCluster()

----------  # @Submenu@ Clone Attributes (Flexible)
self.cloneAttributes(sourceCell=self.parentCell, targetCell=self.childCell, no_clone_key_dict_list=[ATTRIB_1, ATTRIB_2])

----------  # @Submenu@ Child/Parent Random Relative Position
self.setParentChildPositionFlag(0)

----------  # @Submenu@ Child on the Left of the Parent
self.setParentChildPositionFlag(1)

----------  # @Submenu@ Child on the Right of the Parent
self.setParentChildPositionFlag(-1)

----------  # @Submenu@ Divide Cells Along Random Axis (Example)
cells_to_divide = []
for cell in self.cellList:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divideCellRandomOrientation(cell)

----------  # @Submenu@ Divide Cells Along Major Axis (Example)
cells_to_divide = []
for cell in self.cellList:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divideCellAlongMajorAxis(cell)

----------  # @Submenu@ Divide Cells Along Minor Axis (Example)
cells_to_divide = []
for cell in self.cellList:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divideCellAlongMinorAxis(cell)

----------  # @Submenu@ Divide Cells Along Normal To Vector (Example)
cells_to_divide = []
for cell in self.cellList:
    if cell.volume > 50:
        cells_to_divide.append(cell)

for cell in cells_to_divide:
    self.divideCellOrientationVectorBased(cell, 1, 0, 0)  # dividing along Y axis - normal to (1,0,0)

----------  # @Submenu@ Divide Cluster Along Random Axis (Example)
mitosisClusterIdList = []
for compartmentList in self.clusterList:

    clusterId = 0
    clusterVolume = 0
    for cell in CompartmentList(compartmentList):
        clusterVolume += cell.volume
        clusterId = cell.clusterId

    if clusterVolume > 250:  # condition under which cluster mitosis takes place
        mitosisClusterIdList.append(
            clusterId)  # instead of doing mitosis right away we store ids for clusters which should be divide. This avoids modifying cluster list while we iterate through it
for clusterId in mitosisClusterIdList:
    self.divideClusterRandomOrientation(clusterId)

----------  # @Submenu@ Divide Cluster Along Major Axis (Example)
mitosisClusterIdList = []
for compartmentList in self.clusterList:

    clusterId = 0
    clusterVolume = 0
    for cell in CompartmentList(compartmentList):
        clusterVolume += cell.volume
        clusterId = cell.clusterId

    if clusterVolume > 250:  # condition under which cluster mitosis takes place
        mitosisClusterIdList.append(
            clusterId)  # instead of doing mitosis right away we store ids for clusters which should be divide. This avoids modifying cluster list while we iterate through it
for clusterId in mitosisClusterIdList:
    self.divideClusterAlongMajorAxis(clusterId)

----------  # @Submenu@ Divide Cluster Along Minor Axis (Example)
mitosisClusterIdList = []
for compartmentList in self.clusterList:

    clusterId = 0
    clusterVolume = 0
    for cell in CompartmentList(compartmentList):
        clusterVolume += cell.volume
        clusterId = cell.clusterId

    if clusterVolume > 250:  # condition under which cluster mitosis takes place
        mitosisClusterIdList.append(
            clusterId)  # instead of doing mitosis right away we store ids for clusters which should be divide. This avoids modifying cluster list while we iterate through it
for clusterId in mitosisClusterIdList:
    self.divideClusterAlongMinorAxis(clusterId)

----------  # @Submenu@ Divide Cluster Along Normal To Vector (Example)
mitosisClusterIdList = []
for compartmentList in self.clusterList:

    clusterId = 0
    clusterVolume = 0
    for cell in CompartmentList(compartmentList):
        clusterVolume += cell.volume
        clusterId = cell.clusterId

    if clusterVolume > 250:  # condition under which cluster mitosis takes place
        mitosisClusterIdList.append(
            clusterId)  # instead of doing mitosis right away we store ids for clusters which should be divide. This avoids modifying cluster list while we iterate through it
for clusterId in mitosisClusterIdList:
    self.divideClusterOrientationVectorBased(clusterId, 1, 0, 0)

===============  # @Menu@ Parameter Scan Command Line

----------  # @Submenu@ 1. Run Parameter Scan Using Player (Windows)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.bat - i < cc3d
project - file > --guiScan - -maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.bat or runScript.bat]

----------  # @Submenu@ 1. Run Parameter Scan With No GUI (Windows)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.bat - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.bat or runScript.bat]

----------  # @Submenu@ 2. Run Parameter Scan Using Player (Linux)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.sh - i < cc3d
project - file > --guiScan - -maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.sh or runScript.sh]

----------  # @Submenu@ 2. Run Parameter Scan With No GUI (Linux)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.sh - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.sh or runScript.sh]

----------  # @Submenu@ 3. Run Parameter Scan Using Player (OSX)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.command - i < cc3d
project - file > --guiScan - -maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.command or runScript.command]

----------  # @Submenu@ 3. Run Parameter Scan With No GUI (OSX)
# NOTE: THIS COMMAND IS SUPPOSED TO BE EXECUTED IN COMMAND LINE SHELL, NOT IN PYTHON!
paramScan.command - i < cc3d
project - file > --maxNumberOfRuns = 20[remaining
command
line
options
used in compucell3d.command or runScript.command]
