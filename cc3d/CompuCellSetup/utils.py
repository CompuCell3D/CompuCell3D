import re
from pathlib import Path
from lxml import etree
from cc3d.core import XMLUtils
from cc3d import CompuCellSetup
from deprecated import deprecated
from cc3d.core.XMLUtils import ElementCC3D
from cc3d.core.PyCoreSpecs import _PyCoreSpecsBase
import os


LDS_SUBDIR = 'LatticeData'
LDS_FILE = 'StepLDF.dml'
SCREENSHOT_SUBDIR = 'screenshot_data'
SCREENSHOT_SPEC = 'screenshots.json'


def standard_lds_file(_output_dir: str, must_exist=True) -> str:
    """
    Returns the absolute path to the standard location of the lattice data summary file generated by CC3D
    :param _output_dir: absolute path to output directory
    :param must_exist: enforce existence of directory
    :return: {str} absolute path to the standard location of the lattice data summary file
    """
    _output_dir = os.path.abspath(_output_dir)
    if must_exist:
        assert os.path.isdir(_output_dir)
    return os.path.join(_output_dir, LDS_SUBDIR, LDS_FILE)


def standard_screenshot_file(_simulation_dir: str, must_exist=True) -> str:
    """
    Returns the absolute path to the standard location of the screenshot file generated by CC3D
    :param _simulation_dir: absolute path to Simulation directory
    :param must_exist: enforce existence of directory
    :return: {str} absolute path to the standard location of the screenshot file
    """
    _simulation_dir = os.path.abspath(_simulation_dir)
    if must_exist:
        assert os.path.isdir(_simulation_dir)
    return os.path.join(_simulation_dir, SCREENSHOT_SUBDIR, SCREENSHOT_SPEC)


class XML2ObjConverterAdapter:
    def __init__(self):
        self.root = None
        self.xmlTree = None


def init_modules(sim, _cc3dXML2ObjConverter):
    """
    Performs a basic analysis of the CC3D XML content and passes XML structures to C++ code for further initialization
    :param sim:
    :param _cc3dXML2ObjConverter:
    :return:
    """
    validate_cc3d_schema(root_element=_cc3dXML2ObjConverter.root)

    # note, we can always check for multiply defined XML sections in the code belo but introducing
    # XML schema can give us more benefits later in more general cases
    plugin_data_list = XMLUtils.CC3DXMLListPy(_cc3dXML2ObjConverter.root.getElements("Plugin"))
    for pluginData in plugin_data_list:
        sim.ps.addPluginDataCC3D(pluginData)

    steppable_data_list = XMLUtils.CC3DXMLListPy(_cc3dXML2ObjConverter.root.getElements("Steppable"))
    for steppableData in steppable_data_list:
        sim.ps.addSteppableDataCC3D(steppableData)

    potts_data_list = XMLUtils.CC3DXMLListPy(_cc3dXML2ObjConverter.root.getElements("Potts"))
    assert potts_data_list.getBaseClass().size() <= 1, 'You have more than 1 definition of the Potts section'
    if potts_data_list.getBaseClass().size() == 1:
        for pottsData in potts_data_list:
            sim.ps.addPottsDataCC3D(pottsData)

    metadata_data_list = XMLUtils.CC3DXMLListPy(_cc3dXML2ObjConverter.root.getElements("Metadata"))
    assert metadata_data_list.getBaseClass().size() <= 1, 'You have more than 1 definition of the Metadata section'
    if metadata_data_list.getBaseClass().size() == 1:
        for metadataData in metadata_data_list:
            sim.ps.addMetadataDataCC3D(metadataData)


def parseXML( xml_fname):
    """

    :param xml_fname:
    :return:
    """

    cc3dXML2ObjConverter = XMLUtils.Xml2Obj()
    root_element = cc3dXML2ObjConverter.Parse(xml_fname)
    return cc3dXML2ObjConverter

def validate_cc3d_schema(root_element):

    # 0. get schema location
    cc3d_schema_path = Path(CompuCellSetup.__file__).parent.joinpath("xml_schema/cc3d_schema.xsd")

    # 1. Get CC3D XML as a Python string
    xml_str = root_element.getCC3DXMLElementString()

    # 2. Parse the schema
    schema_doc = etree.parse(cc3d_schema_path)
    schema = etree.XMLSchema(schema_doc)

    # 3. Parse the XML string directly
    doc = etree.fromstring(xml_str.encode("utf-8"))

    # 4. Validate
    if schema.validate(doc):
        print("XML is valid!")
        return True

    # -----------------------------------
    #  Human-Readable Error Output
    # -----------------------------------
    clean_messages = []

    for error in schema.error_log:
        msg = error.message
        handled = False  # TRACK IF WE CONSUME THIS ERROR

        # -------------------------------
        # Duplicate plugin names
        # -------------------------------
        m = re.search(r"Duplicate key-sequence \['(.+?)'\].+AllPluginsHaveUniqueNames", msg)
        if m:
            plugin_name = m.group(1)
            clean_messages.append(
                f"Plugin '{plugin_name}' was listed more than once.\n"
                f"You can only list a given plugin once in a CC3D simulation file."
            )
            handled = True

        # -------------------------------
        # Duplicate steppable types
        # -------------------------------
        m = re.search(r"Duplicate key-sequence \['(.+?)'\].+AllSteppablesHaveUniqueTypes", msg)
        if m:
            step_type = m.group(1)
            clean_messages.append(
                f"Steppable '{step_type}' was listed more than once.\n"
                f"Each Steppable Type may only appear once in a CC3D simulation."
            )
            handled = True

        # -------------------------------
        # Duplicate Potts / Metadata
        # -------------------------------
        for section_error_sig, section_name in [
            ("UniquePottsSection", "<Potts>"),
            ("UniqueMetadataSection", "<Metadata>")
        ]:
            if section_error_sig in msg:
                clean_messages.append(
                    f"You listed {section_name} section more than once."
                    f"You can only have one {section_name} section in a CC3D simulation file."
                )
                handled = True

        # -------------------------------
        # Generic fallback *ONLY IF NOT HANDLED*
        # -------------------------------
        if not handled:
            clean_messages.append(f"XML Schema Error: {msg}")

    # -------------------------------------
    # Remove duplicate messages (preserve order)
    # -------------------------------------
    unique_clean_messages = list(dict.fromkeys(clean_messages))

    # Raise clean combined exception
    raise RuntimeError(
        "Invalid CC3D XML:\n\n" +
        "\n\n".join(unique_clean_messages)
    )

    # def validate_cc3d_schema(root_element):
#
#
#     # 0. get schema location
#     cc3d_schema_path = Path(CompuCellSetup.__file__).parent.joinpath("xml_schema/cc3d_schema.xsd")
#
#     # 1. Get CC3D XML as a Python string
#     xml_str = root_element.getCC3DXMLElementString()
#
#     # 2. Parse the schema
#     schema_doc = etree.parse(cc3d_schema_path)
#     schema = etree.XMLSchema(schema_doc)
#
#     # 3. Parse the XML string directly
#     doc = etree.fromstring(xml_str.encode("utf-8"))
#
#     # 4. Validate
#     if schema.validate(doc):
#         print("XML is valid!")
#         return True
#
#     # -----------------------------------
#     #  Human-Readable Error Output
#     # -----------------------------------
#     clean_messages = []
#
#     for error in schema.error_log:
#         msg = error.message
#
#         # Detect duplicate plugin names
#         m = re.search(r"Duplicate key-sequence \['(.+?)'\].+AllPluginsHaveUniqueNames", msg)
#         if m:
#             plugin_name = m.group(1)
#             clean_messages.append(
#                 f"Plugin '{plugin_name}' was listed more than once."
#                 f"You can only list a given plugin once in a CC3D simulation file."
#             )
#             continue
#
#         # Detect duplicate steppable names
#         m = re.search(r"Duplicate key-sequence \['(.+?)'\].+AllSteppablesHaveUniqueTypes", msg)
#         if m:
#             step_type = m.group(1)
#             clean_messages.append(
#                 f"Steppable '{step_type}' was listed more than once."
#                 f"Each Steppable Type may only appear once in a CC3D simulation."
#             )
#             continue
#
#         # Detect duplicate Potts and Metadata sections
#         for section_error_signature, section_name in [("UniquePottsSection", "<Potts>"), ("UniqueMetadataSection", "<Metadata>")]:
#             m = re.search(section_error_signature, msg)
#             if m:
#                 clean_messages.append(
#                     f"You listed {section_name} section more than once. You can only have one <Potts> section."
#
#                 )
#
#         #
#         # m = re.search(r"UniquePottsSection", msg)
#         # if m:
#         #     clean_messages.append(
#         #         f"You listed <Potts> section more than once. You can only have one <Potts> section."
#         #
#         #     )
#         #     continue
#         #
#         # # Detect duplicate Potts sections
#         # m = re.search(r"UniqueMetadataSection", msg)
#         # if m:
#         #     clean_messages.append(
#         #         f"You listed <Metadata> section more than once. You can only have one <Metadata> section."
#         #
#         #     )
#         #     continue
#
#         # Generic fallback
#         clean_messages.append(f"XML Schema Error: {msg}")

    # Raise a clean combined exception
    raise RuntimeError(
        "Invalid CC3D XML:\n" +
        "\n\n".join(clean_messages)
    )

    # else:
    #     print("XML validation errors:")
    #     print(schema.error_log)
    #     raise RuntimeError(f"Invalid CC3D XML: {schema.error_log}")



@deprecated(version='4.0.0', reason="You should use : set_simulation_xml_description")
def setSimulationXMLDescription(_xmlTree):
    """

    :param _xmlTree:
    :return:
    """
    return set_simulation_xml_description(xml_tree=_xmlTree)


def set_simulation_xml_description(xml_tree: ElementCC3D) -> None:
    """
    
    :param xml_tree: 
    :return: 
    """
    CompuCellSetup.persistent_globals.cc3d_xml_2_obj_converter = XML2ObjConverterAdapter()
    cc3d_xml_2_obj_converter = CompuCellSetup.persistent_globals.cc3d_xml_2_obj_converter
    cc3d_xml_2_obj_converter.xmlTree = xml_tree
    cc3d_xml_2_obj_converter.root = xml_tree.CC3DXMLElement


def register_specs(*_specs) -> None:
    """
    Register core specification with CC3D

    :param _specs: variable number of _PyCoreSpecsBase-derived class instances
    :return: None
    """
    for _spec in _specs:
        if not issubclass(type(_spec), _PyCoreSpecsBase):
            raise TypeError("Not a core specs instance")
        CompuCellSetup.persistent_globals.core_specs_registry.register_spec(_spec)
    CompuCellSetup.persistent_globals.core_specs_registry.inject()


def getSteppableRegistry():
    """
    returns steppable registry object from persistent globals. Legacy function
    :return: {SeppableRegistry
    """
    return CompuCellSetup.persistent_globals.steppable_registry

